<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F14%2Fbash_case%E8%AF%AD%E5%8F%A5%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Cobbler服务自动化安装部署系统]]></title>
    <url>%2F2017%2F10%2F27%2FCobbler%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Cobbler将DHCP、TFTP、DNS、HTTP等服务进行集成，实现自动化安装部署 cobbler 服务集成 PXE DHCP rsync HTTP DNS Kickstart IPMI 电源管理 安装前准备（注意） 磁盘空间：单镜像大于10G 内存空间：目标设备内存大于1G yum源配置 准备镜像文件 selinux iptables firewalld 查看版本和内核信息 查看本机网卡信息 1234[root@cobbler ~]# uname -aLinux cobbler 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux[root@cobbler ~]# cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core) 安装cobbler yum install cobbler -y cobbler 命令 123456[root@cobbler ~]# cobbler --helpusage=====cobbler &lt;distro|profile|system|repo|image|mgmtclass|package|file&gt; ... [add|edit|copy|getks*|list|remove|rename|report] [options|--help]cobbler &lt;aclsetup|buildiso|import|list|replicate|report|reposync|sync|validateks|version|signature|get-loaders|hardlink&gt; [options|--help] 显示套件的文件列表 rpm -ql cobbler | grep service rpm -qf cobbler 查看端口状态 ss -nul 查看文件信息12[root@cobbler tftpboot]# ls /var/lib/tftpboot/boot etc grub images images2 memdisk menu.c32 ppc pxelinux.0 pxelinux.cfg s390x yaboot 相关服务重启并加入开机启动项123456systemctl enable cobblerd.servicesystemctl start cobblerdsystemctl enable tftpsystemctl start tftpsystemctl enable httpdsystemctl start httpd 效验配置cobber1234567891011121314151617181920212223[root@cobbler ~]# cobbler checkThe following are potential configuration items that you may want to fix:1 : The &apos;server&apos; field in /etc/cobbler/settings must be set to something other than localhost, or kickstarting features will not work. This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it. # server：域问题2 : For PXE to be functional, the &apos;next_server&apos; field in /etc/cobbler/settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network. # next_server：tftp服务问题3 : change &apos;disable&apos; to &apos;no&apos; in /etc/xinetd.d/tftp # 非独立服务问题：第一项解决同时解决4 : some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run &apos;cobbler get-loaders&apos; to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely. Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The &apos;cobbler get-loaders&apos; command is the easiest way to resolve these requirements. # boot-loaders丢失文件：要求链接互联网，运行cobbler get-loaders。没有网络情况拷贝内核文件 cp /var/lib/tftpboot/&#123;menu.c32,pxelinux.0&#125; /var/lib/cobbler/loaders5 : enable and start rsyncd.service with systemctl # rsync：同步问题可以忽略6 : debmirror package is not installed, it will be required to manage debian deployments and repositories # debmirror包未安装：debian系统，现在使用的是centos，忽略7 : ksvalidator was not found, install pykickstart # 未找到pykickstart8 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to &apos;cobbler&apos; and should be changed,try: &quot;openssl passwd -1 -salt &apos;random-phrase-here&apos; &apos;your-password-here&apos;&quot; to generate new one # 默认口令问题9 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them # fencing集群相关可以忽略Restart cobblerd and then run &apos;cobbler sync&apos; to apply changes. 解决方法： 1234567891011121314vim /etc/cobbler/settings修改384行server： 192.168.1.51修改272行next_server: 192.168.1.51修改101行:&quot;$1$mF86/UHC$WvcIcX2t6crBz2onWxyac.&quot;为MD5文件生成先制作密码，另开启终端制作亦可。openssl passwd -1 Password: Verifying - Password: $1$4i6hacNZ$0.QlS0Z4w6oat8c.wJxCy0记住密码，替换为default_password_crypted: &quot;$1$4i6hacNZ$0.QlS0Z4w6oat8c.wJxCy0&quot; 注：解决过程中每次都需要重新验证并重启服务，也可以一起排查再重启服务,同时有些服务可能已经解决还会报错，可以忽略。命令如下123cobbler checksystemctl restart cobblerdcobbler sync 当上述配置无问题可以进行下一环节DHCP配置 出现错误补充：效验过程中可能出现另一种报错，该报错信息并非上面提示，一般不会cobbler问题而是软件包依赖或者其他问题那么需要逐个排查后再进行效验配置。报错信息例如下面提示1234567891011121314151617181920212223242526[root@cobbler ~]# cobbler checkhttpd does not appear to be running and proxying cobbler, or SELinux is in the way. Original traceback:Traceback (most recent call last): File &quot;/usr/lib/python2.7/site-packages/cobbler/cli.py&quot;, line 251, in check_setup s.ping() File &quot;/usr/lib64/python2.7/xmlrpclib.py&quot;, line 1233, in __call__ return self.__send(self.__name, args) File &quot;/usr/lib64/python2.7/xmlrpclib.py&quot;, line 1587, in __request verbose=self.__verbose File &quot;/usr/lib64/python2.7/xmlrpclib.py&quot;, line 1273, in request return self.single_request(host, handler, request_body, verbose) File &quot;/usr/lib64/python2.7/xmlrpclib.py&quot;, line 1301, in single_request self.send_content(h, request_body) File &quot;/usr/lib64/python2.7/xmlrpclib.py&quot;, line 1448, in send_content connection.endheaders(request_body) File &quot;/usr/lib64/python2.7/httplib.py&quot;, line 1013, in endheaders self._send_output(message_body) File &quot;/usr/lib64/python2.7/httplib.py&quot;, line 864, in _send_output self.send(msg) File &quot;/usr/lib64/python2.7/httplib.py&quot;, line 826, in send self.connect() File &quot;/usr/lib64/python2.7/httplib.py&quot;, line 807, in connect self.timeout, self.source_address) File &quot;/usr/lib64/python2.7/socket.py&quot;, line 571, in create_connection raise errerror: [Errno 111] Connection refused 上述报错信息提示很清楚是HTTP相关服务未启用解决思路方法： selinux iptables firewalld getenforce systemctl enable httpd systemctl start httpd 安装配置DHCPdhcp可以交给Cobbler 管理,也可以自己独立进行管理,如果dhcp配置文件有误,会导致dhcpd服务无法启动, 如果是cobbler 管理可能导致 cobbler也无法启动 使用cobbler管理DHCP123456789101112131415161718192021222324252627282930313233[root@cobbler ~]# vim /etc/cobbler/settings# 修改242行：让cobbler管理DHCPmanage_dhcp: 1[root@cobbler ~]# cat /etc/dhcp/dhcpd.conf## DHCP Server Configuration file.# see /usr/share/doc/dhcp*/dhcpd.conf.example# see dhcpd.conf(5) man page#[root@cobbler ~]# vim /etc/cobbler/dhcp.templatesubnet 192.168.1.0 netmask 255.255.255.0 &#123; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.1.100 192.168.1.254; default-lease-time 21600; max-lease-time 43200; next-server $next_server; class &quot;pxeclients&quot; &#123; match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;; if option pxe-system-type = 00:02 &#123; filename &quot;ia64/elilo.efi&quot;; &#125; else if option pxe-system-type = 00:06 &#123; filename &quot;grub/grub-x86.efi&quot;; &#125; else if option pxe-system-type = 00:07 &#123; filename &quot;grub/grub-x86_64.efi&quot;; &#125; else &#123; filename &quot;pxelinux.0&quot;; &#125; &#125;&#125; 自管理DHCP123456789101112131415161718192021# 可以粘贴模版也可以自己写[root@cobbler ~]# cp /usr/share/doc/dhcp*/dhcpd.conf.example dhcpd.conf[root@cobbler ~]# grep -v &quot;^#&quot; /etc/dhcp/dhcpd.conf[root@cobbler ~]# vim /etc/dhcp/dhcpd.conf# option definitions common to all supported networks...option domain-name &quot;nigaha.com&quot;;option domain-name-servers 114.114.114.114,8.8.8.8;default-lease-time 86400;max-lease-time 86400;# This is a very basic subnet declaration.subnet 192.168.1.0 netmask 255.255.255.0 &#123; range 192.168.1.101 192.168.1.200; option routers 192.168.0.1; next-server 192.168.1.51; filename &quot;pxelinux.0&quot;;&#125; 注意： dhcp配置文件每行末尾的分号 不要将本机IP分配到地址池 配置完毕重启服务，并加入开机启动项 导入镜像 distrocobbler 导入镜像其实就是复制镜像的文件到 /var/www/cobbler/ks_mirror 有光盘挂载光盘没有光盘使用 -o loop 挂载iso文件1234567[root@cobbler ~]# mount /dev/cdrom /media/[root@cobbler ~]# cd /var/www/cobbler/ks_mirror[root@cobbler ks_mirror]# cobbler import --name=centos6.9-x86_64 --path=/media# 列出发行版distro[root@cobbler ks_mirror]# cobbler distro list# 列出各种发行版的不同安装方式, 也就是网卡启动后的菜单界面[root@cobbler ks_mirror]# cobbler profile list copy完成后，Cobbler 服务器已经搭建好了： 菜单选项profile 发行版本distro这个菜单选项是cobbler 自己自动生成的 菜单文件位置为： /var/lib/tftpboot/pxelinux.cfg/default镜像文件目录： /var/www/cobbler/ks_mirror查看目录结构可以访问： http://192.168.1.51/cobbler这个默认的安装方式是最小化安装,使用的目录文件为： /var/lib/cobbler/kickstarts/sample_end.ks 相关命令123456789101112131415161718192021222324[root@cobbler ~]# cobbler profile --helpusage=====cobbler profile addcobbler profile copycobbler profile dumpvarscobbler profile editcobbler profile findcobbler profile getkscobbler profile listcobbler profile removecobbler profile renamecobbler profile report[root@cobbler ~]# cobbler distro --helpusage=====cobbler distro addcobbler distro copycobbler distro editcobbler distro findcobbler distro listcobbler distro removecobbler distro renamecobbler distro report 导入ks.cfg文件ks.cfg 文件目录为：/etc/lib/cobbler/kickstarts默认文件/var/lib/cobbler/kickstarts/sample_end.ks 语法为123cobbler profile add --name=&lt;菜单上的条目&gt; --distro=&lt;发行版&gt; --kickstart=&lt;文件路径&gt; # 增加ks.cfgcobbler profile edit --name=&lt;菜单上的条目&gt; --kickstart=&lt;文件路径&gt; # 修改ks.cfgcobbler profile remove --name=&lt;菜单上的条目&gt; 将 ks.cfg 文件复制到对应目录为 /etc/lib/cobbler/kickstarts增加和修改ks文件的命令注意区别，修改不需要指定 --distro 因为 --name 指定的profile 已经存在且自己知道之前是与那个发行版 (distro) 绑定修改或增加后要运行 cobbler sync 同步 和重启服务 语法示例123cobbler profile add --name=centos6-test --distro=centos6.9-x86_64 --kickstart=/var/lib/cobbler/kickstart/centos6-test-ks.cfgcobbler syncservice cobblerd restart 自定义ks.cfg文件ks.cfg文件制作方法本机安装的 ananaconda-ks.cfg 稍作修改，目录为1234[root@cobbler ~]# lsanaconda-ks.cfg[root@cobbler ~]# pwd/root 或者使用 system-congif-kickstart 图形界面软件自行制作,将 ks.cfg 文件复制并修改名称，路径为：/var/lib/cobbler/kickstarts/完成后使用 ksvalidator 检查文件语法（注意目录）例：ksvalidator centos6-test-ks.cfg ks.cfg 参考文件注：此应答文件仅供参考，具体环境具体修改！centos 6.9 应答文件参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#platform=x86, AMD64, or Intel EM64T#version=DEVEL# Firewall configurationfirewall --disabled# Install OS instead of upgradeinstall# url需要修改可以用cobbler里内置的变量$tree , 可以直接指定路径# Use network installationurl --url=$tree# 安装后的密码可以使用cobbler配置文件里的变量 $default_password_crypted 也可手动生成# Root passwordrootpw --iscrypted $default_password_crypted# System authorization informationauth --useshadow --passalgo=sha512# 使用文本安装# Use text mode installtextfirstboot --disable# System keyboardkeyboard us# System languagelang en_US# SELinux configurationselinux --disabled# Do not configure the X Window System# 跳过图形skipx# Installation logging levellogging --level=info# Reboot after installationreboot# System timezonetimezone Asia/Shanghai# Network informationnetwork --bootproto=dhcp --device=eth0 --onboot=on# System bootloader configurationbootloader --location=mbr# Clear the Master Boot Recordzerombr# Partition clearing informationclearpart --all --initlabel # Disk partitioning informationpart /boot --fstype=&quot;ext4&quot; --ondisk=sda --size=300part / --fstype=&quot;ext4&quot; --ondisk=sda --size=10240part /usr --fstype=&quot;ext4&quot; --grow --ondisk=sda --size=1part swap --fstype=&quot;swap&quot; --ondisk=sda --size=1024# 注意安装后脚本定义,定义在安装包前面%post# 导入公钥#!/bin/bash[ -d /root/.ssh ] || mkdir /root/.sshcat &gt;&gt; /root/.ssh/authorized_keys &lt;&lt; EOFssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA0JO+fs+MtFZYnTTQR7t43ApwzU2H6YPTdTdjfNCUTqmHrO0gAbRe7c+DuesntZb31pmW2wHuB8KyU3i1IFYKDB7ccyvqpfOjfWFKKW34/qpdLWoJ0NlnlgFkmySVX+YsPX0FbxY3yEFNiLXSI95h6U12h0TUPkUxrvZuZZgWIqxNQhu3rOr0nT8jhxfyOnfXxM2+xNVoVAqq+C0zJfYsY0C41IjMFCavSMeKA/OBmgsU4Vg3OQoMx7hDXPB01sRWrDvUp6fea8knnY3QG0imI0K5/T7bRevY7s+Gq11twam9+WPzjXIoKnqMSX785WhqMxEPns8mkxCNrbmIsdTqyQ==EOFchmod -R 600 /root/.sshmkdir /etc/yum.repos.d/repo.bakmv /etc/yum.repos.d/*.repo /etc/yum.repos.d/repo.bakcat &gt; /etc/yum.repos.d/yumy.repo &lt;&lt; EOF[base]name=yumy.basebaseurl=http://172.18.0.1/centos/6/gpgcheck=0[epel]name=yumy.epelbaseurl=http://172.18.0.1/fedora-epel/6/x86_64/gpgcheck=0EOF# 设定主机名ClientName=`ifconfig eth0 | awk &apos;/inet addr:/&#123;print $2&#125;&apos; | awk -F. &apos;&#123;print $NF&#125;&apos;`sed -i &quot;s@HOSTNAME=.*@HOSTNAME=client$ClientName.yy.com@g&quot; /etc/sysconfig/networkcat &gt; /etc/sysconfig/network-scripts/ifcfg-eth1 &lt;&lt;EOFDEVICE=eth1BOOTPROTO=staticIPADDR=172.18.51.$ClientNamePREFIX=16GATEWAY=172.18.0.1DNS1=172.18.0.1EOFcat &gt; /etc/sysconfig/network-scripts/ifcfg-eth0 &lt;&lt;EOFDEVICE=eth0BOOTPROTO=staticIPADDR=192.168.1.$ClientNamePREFIX=24EOF%end# 定义安装软件包%packages@base@compat-libraries@debugging@development@server-platform-devellrzsztree%end centos 7.3应答文件参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#platform=x86, AMD64, or Intel EM64T#version=DEVEL# Install OS instead of upgradeinstall# Keyboard layoutskeyboard &apos;us&apos;# Root passwordrootpw --iscrypted $default_password_crypted# Use network installationurl --url=$tree# System languagelang en_US# Firewall configurationfirewall --disabled# System authorization informationauth --useshadow --passalgo=sha512# Use text mode installtext# SELinux configurationselinux --disabled# Do not configure the X Window Systemskipx# Network informationnetwork --bootproto=dhcp --device=ens32 --onboot=on --ipv6=auto# Reboot after installationreboot# System timezonetimezone Asia/Shanghai# System bootloader configurationbootloader --location=mbr # Clear the Master Boot Recordzerombr# Partition clearing informationclearpart --all --initlabel# Disk partitioning informationpart /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=300part / --fstype=&quot;xfs&quot; --ondisk=sda --size=10240part /usr --fstype=&quot;xfs&quot; --grow --ondisk=sda --size=1part swap --fstype=&quot;swap&quot; --size=1024%post[ -d /root/.ssh ] || mkdir /root/.sshcat &gt;&gt; /root/.ssh/authorized_keys &lt;&lt; EOFssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA0JO+fs+MtFZYnTTQR7t43ApwzU2H6YPTdTdjfNCUTqmHrO0gAbRe7c+DuesntZb31pmW2wHuB8KyU3i1IFYKDB7ccyvqpfOjfWFKKW34/qpdLWoJ0NlnlgFkmySVX+YsPX0FbxY3yEFNiLXSI95h6U12h0TUPkUxrvZuZZgWIqxNQhu3rOr0nT8jhxfyOnfXxM2+xNVoVAqq+C0zJfYsY0C41IjMFCavSMeKA/OBmgsU4Vg3OQoMx7hDXPB01sRWrDvUp6fea8knnY3QG0imI0K5/T7bRevY7s+Gq11twam9+WPzjXIoKnqMSX785WhqMxEPns8mkxCNrbmIsdTqyQ==EOFchmod -R 600 /root/.ssh mkdir /etc/yum.repos.d/repo.bakmv /etc/yum.repos.d/*.repo /etc/yum.repos.d/repo.bakcat &gt; /etc/yum.repos.d/yumy.repo &lt;&lt; EOF[base]name=yumy.basebaseurl=http://172.18.0.1/centos/7/gpgcheck=0[epel]name=yumy.epelbaseurl=http://172.18.0.1/fedora-epel/7/x86_64/gpgcheck=0EOF# set hostname with end of ip addressClientName=`ifconfig ens32 | awk &apos;/inet /&#123;print $2&#125;&apos; | awk -F. &apos;&#123;print $NF&#125;&apos;`echo &quot;Client$&#123;ClientName&#125;.yy.com&quot; &gt; /etc/hostname# delete network interface ens*rm -rf /etc/sysconfig/network-scripts/ifcfg-ens*# rename ens33 to eth0sed -i.bak &quot;/vmlinuz-`uname -r`/s@quiet@quiet net.ifnames=0@&quot; /boot/grub2/grub.cfgcat &gt; /etc/sysconfig/network-scripts/ifcfg-eth0 &lt;&lt;EOFNAME=&quot;eth0&quot;DEVICE=&quot;eth0&quot;ONBOOT=yesBOOTPROTO=noneIPADDR=192.168.1.$ClientNamePREFIX=24EOFcat &gt; /etc/sysconfig/network-scripts/ifcfg-eth1 &lt;&lt;EOFNAME=&quot;eth1&quot;DEVICE=&quot;eth1&quot;ONBOOT=yesBOOTPROTO=noneIPADDR=172.18.51.$ClientNamePREFIX=16EOF%end%packages@base@compat-libraries@debugging@development@platform-develabrt-console-notificationbash-completionblktracebridge-utils%end 使用Cobbler-Web来管理Cobblerweb用户认证的方式由多种,这里采用系统默认的认证配置文件中定义123/etc/cobbler/modules.confmodule = authn_configfile 123456[root@client100 ~]# yum install cobbler-web [root@client100 ~]# htdigest -c /etc/cobbler/users.digest Cobbler &lt;用户名&gt;# 上面的命令 -c 表示创建认证文件 Cobbler 是关键字, 如果创建多个用户管理无需使用 -c 选项# htdigest 是由 httpd-tools 软件包提供[root@client100 ~]# service httpd restart [root@client100 ~]# service cobblerd restart 重启后使用 https://192.168.1.51/cobbler_web 默认的用户和密码都为cobbler 修改用户名和密码： 1# htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; cobbler # “描述” 用户 输入此命令后，会提示修改密码。 修改Cobbler的启动安装界面Cobbler的启动安装界面可以有自定义的提示，通修改pxe的模板文件来实现： 12345678910111213[root@cobbler ~]# cat /etc/cobbler/pxe/pxedefault.templateDEFAULT menuPROMPT 0MENU TITLE Cobbler this is test==^-^ | #提示栏信息 TIMEOUT 200TOTALTIMEOUT 6000ONTIMEOUT $pxe_timeout_profileLABEL local #默认的启动列表 MENU LABEL (local) MENU DEFAULT LOCALBOOT -1$pxe_menu_itemsMENU end 执行sync 使命令生效： 1# cobbler sync Cobbler功能特性: 快速网络安装linux 操作系统的服务，支持众多的Linux 发行版：Red Hat 、Fedora 、CentOS 、Debian 、Ubuntu和SuSE ，也可以支持网络安装windows PXE 的二次封装，将多种安装参数封装到一个菜单 Python 编写 提供了CLI 和Web的管理形式 Cobbler 目录作用总结数据目录 /var/lib/cobbler/config :用于存放distros，system，profiles 等信息配置文件 /var/lib/cobbler/triggers : 用于存放用户定义的cobbler命令 /var/lib/cobbler/kickstart : 默认存放kickstart文件 /var/lib/cobbler/loaders : 存放各种引导程序镜像目录 /var/www/cobbler/ks_mirror/ :导入的发行版系统的所有数据目录, /var/www/cobbler/images :导入发行版的kernel和initrd镜像用于远程网络启动 /var/www/cobbler/repo_mirror/ : yum 仓库存储目录日志文件 /var/log/cobbler/installing :客户端的安装日志 /var/log/cobbler/cobbler.log :cobbler日志cobbler 配置文件总结配置文件目录 /etc/cobbler /etc/cobbler/settings : cobbler 主配置文件 /etc/cobbler/iso/ : iso模板配置文件 /etc/cobbler/pxe : pxe模板文件 /etc/cobbler/power : 电源配置文件 /etc/cobbler/user.conf : web服务授权配置文件 /etc/cobbler/users.digest : web访问的用户名密码配置文件 /etc/cobbler/dhcp.template : dhcp服务器的的配置末班 /etc/cobbler/dnsmasq.template : dns服务器的配置模板 /etc/cobbler/tftpd.template : tftp服务的配置模板 /etc/cobbler/modules.conf : 模块的配置文件]]></content>
      <categories>
        <category>cobbler</category>
      </categories>
      <tags>
        <tag>自动化安装系统</tag>
        <tag>cobbler</tag>
        <tag>DHCP</tag>
        <tag>Kickstart应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX KERNEL启动参数]]></title>
    <url>%2F2017%2F08%2F19%2FLINUX%20KERNEL%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[kernel在grub中配置的启动参数 在Linux中，给kernel传递参数以控制其行为总共有三种方法： 1. build kernel之时的各个configuration选项。 2. 当kernel启动之时，可以参数在kernel被GRUB或LILO等启动程序调用之时传递给kernel。 3.在kernel运行时，修改/proc或/sys目录下的文件。 这里讲的就是第二种方式了，kernel在grub中配置的启动参数。 首先，kernel有哪些参数呢？ 在linux的源代码中，有这样的一个文档Documentation/kernel-parameters.txt ，它介绍了kernel的各个参数及其意义。 其次，kernel启动参数以空格分隔，而且是严格区分大小写的 例如：mem和MEM是不一样的 再次，对于module特有的kernel参数写法是这样的，[module name].[parameter=XX]， 例如，igb.max_vfs=7 这个kernel启动参数的效果就是相当于这样来动态加载module: modprobe igb max_vfs=7 另外，kernel是怎样处理这些启动参数的呢？ 启动参数通常是这样的形式： name[=value_1][,value_2]…[,value_10] “name”是关键字，内核用它来识别应该把”关键字”后面的值传递给谁，也就是如何处理这个值，是传递给处理进程还是作为环境变量或者抛给”init”。 值的个数限制为10，你可以通过再次使用该关键字使用超过10个的参数。 kernel检查关键字是不是 ‘root=’, ‘nfsroot=’, ‘nfsaddrs=’, ‘ro’, ‘rw’, ‘debug’ 或 ‘init’ 内核在bootsetups数组里搜索于该关键字相关联的已注册的处理函数，如果找到相关的已注册的处理函数，则调用这些函数并把关键字后面的值作为参数传递给这些函数。 比如，你在启动时设置参数 name＝a、b、c、d，内核搜索 bootsetups 数组，如果发现”name”已注册，则调用”name”的设置函数如 name_setup()，并把 a、b、c、d 传递给 name_setup() 执行。 所有型如”name＝value”参数，如果没有被上面所述的设置函数接收，将被解释为系统启动后的环境变量 比如”TERM=vt100”启动参数就会被作为一个启动后的环境变量。 所有没有被内核设置函数接收也没又被设置成环境变量的参数都将留给init进程处理 比如”single” 下面简单总结一些常用到的一些kernel启动参数。 根磁盘相关启动参数： root # 指出启动的根文件系统 如：root=/dev/sda1 ro # 指定根设备在启动过程中为read-only，默认情况下一般都是这样配的 rw # 和ro类似，它是规定为read-write，可写 rootfstype # 根文件系统类型，如：rootfstype=ext4 Console和kernel log相关启动参数： console # console的设备和选项，如：console=tty0 console=ttyS0 debug # enable kernel debugging 启动中的所有debug信息都会打印到console上 quiet # disable all log messages 将kernel log level设置为KERN_WARNING，在启动中只非常严重的信息 loglevel # 设置默认的console日志级别，如：loglevel=7 （0~7的数字分别为：KERN_EMERG,..,KERN_DEBUG） time # 设置在每条kernel log信息前加一个时间戳 内存相关的启动参数： mem # 指定kernel使用的内存量，mem=n[KMG] hugepages # 设置大页表页（4MB大小）的最多个数，hugepages=n CPU相关的启动参数： mce # Enable the machine check exception feature. nosmp # Run as a single-processor machine. 不使用SMP（多处理器） max_cpus # max_cpus=n, SMP系统最多能使用的CPU个数（即使系统中有大于n个的CPU） Ramdisk相关的启动参数： initrd # 指定初始化ramdisk的位置，initrd=filename noinitrd # 不使用initrd的配置，即使配置了initrd参数 初始化相关启动参数： init # 在启动时去执行的程序，init=filename，默认值为/sbin/init PCI相关的启动参数： pci # pci相关的选项，我常使用pci=assign_buses，也使用过pci=nomsi SELinux相关启动参数： enforcing # SELinux enforcing状态的开关，enforcing=0表示仅仅是记录危险而不是阻止访问，enforcing=1完全enable，默认值是0 selinux # 在启动时关闭或开启SELinux，selinux=0表示关闭，selinux=1表示开启selinux 另外，还是用max_loop来指定最多可使用的回路设备。 在Redhat的系统中，还有个经常看到的kernel启动参数——rhgb，rhgb表示redhat graphics boot，就是会看到图片来代替启动过程中显示的文本信息，这些信息在启动后用dmesg也可以看到rhgb = redhat graphical boot – This is a GUI mode booting screen with most of the information hidden while the user sees a rotating activity icon spining and brief information as to what the computer is doing. quiet = hides the majority of boot messages before rhgb starts. These are supposed to make the common user more comfortable. They get alarmed about seeing the kernel and initializing messages, so they hide them for their comfort. 参考资料:linux kernel documents 《Linux kernel in a nutshell》]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用RAID技术总结]]></title>
    <url>%2F2017%2F07%2F21%2FRAID(Redundant%20Array%20of%20Independent%20Disks)%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常用RAID(Redundant Array of Independent Disks)技术总结 RAID 0 : RAID 0 并不是真正的RAID结构，没有数据冗余，没有数据校验的磁盘陈列。 实现RAID 0至少需要两块以上的硬盘，它将两块以上的硬盘合并成一块，数据连续地分割在每块盘上。因为带宽加倍，所以读/写速度加倍， 但RAID 0在提高性能的同时，并没有提供数据保护功能，只要任何一块硬盘损坏就会丢失所有数据。因此RAID 0 不可应用于需要数据高可用性的关键领域。 RAID 1 : RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。 当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。RAID 1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。RAID 1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAID 0磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID 1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID 1磁盘阵列一般支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID 1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID 1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。 RAID 10 : RAID 1+0 也被称为RAID 10标准，实际是将RAID 0和RAID 1标准结合的产物，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘作磁盘镜像进行冗余。 它的优点是同时拥有RAID 0的超凡速度和RAID 1的数据高可靠性，但是CPU占用率同样也更高，而且磁盘的利用率比较低。由于利用了RAID 0极高的读写效率和RAID 1较高的数据保护、恢复能力，使RAID 10成为了一种性价比较高的等级，目前几乎所有的RAID控制卡都支持这一等级。但是，RAID 10对存储容量的利用率和RAID 1一样低，只有50%。因此，RAID10即高可靠性与高效磁盘结构它是一个带区结构加一个镜象结构，可以达到既高效又高速的目的，RAID 10能提供比RAID 5更好的性能。这种新结构的可扩充性不好，这种解决方案被广泛应用，使用此方案比较昂贵。 RAID 5 : RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。RAID 5可以为系统提供数据安全保障，但保障程度要比Mirror低而磁盘空间利用率要比Mirror高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前运用较多的一种解决方案。RAID5数据以块为单位分布到各个硬盘上。RAID 5不对数据进行备份，而是把数据和与其相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。 RAID 6 : RAID6技术是在RAID 5基础上，为了进一步加强数据保护而设计的一种RAID方式，实际上是一种扩展RAID 5等级。 与RAID 5的不同之处于除了每个硬盘上都有同级数据XOR校验区外，还有一个针对每个数据块的XOR校验区。当然，当前盘数据块的校验数据不可能存在当前盘而是交错存储的，这样一来，等于每个数据块有了两个校验保护屏障（一个分层校验，一个是总体校验），因此RAID 6的数据冗余性能相当好。但是，由于增加了一个校验，所以写入的效率较RAID 5还差，而且控制系统的设计也更为复杂，第二块的校验区也减少了有效存储空间。RAID-6和RAID-5一样对逻辑盘进行条带化然后存储数据和校验位，只是对每一位数据又增加了一位校验位。这样在使用RAID-6时会有两块硬盘用来存储校验位，增强了容错功能，同时必然会减少硬盘的实际使用容量。以前的raid级别一般只允许一块硬盘坏掉，而RAID-6可以允许坏掉两块硬盘，因此，RAID-6 要求至少4块硬盘。 常用RAID图示 常用RAID比较结论 RAID类型 访问速度 数据可靠性 磁盘利用率 RAID 0 很快 很低 100% RAID 1 很慢 很高 50% RAID 10 中等 很高 50% RAID 5 较快 较高 (n-1)/n RAID 6 较快 较(RAID5)高 (n-2)/n 更多信息请参照百度 参考资料百度百科 - RAID 0 : 百度百科 - RAID 0 百度百科 - RAID 1 : 百度百科 - RAID 1 百度百科 - RAID 10 : 百度百科 - RAID 10 百度百科 - RAID 5 : 百度百科 - RAID 5 百度百科 - RAID 6 : 百度百科 - RAID 6]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>RAID</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_RPM命令管理]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_RPM%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——RPM命令管理 RPM包命名原则 httpd-2.2.15-15.el6.centos.1.i686.rpm httpd软件包名 2.2.15软件版本 15软件发布的次数 el6.centos适合的linux平台,可能为rhel6代表Redhat6 i686适合的硬件平台，可能i386,x86_64,x64等 rpm rpm包扩展名 RPM包依赖 树形依赖：a-&gt;b-&gt;c 环形依赖：a-&gt;b-&gt;c-&gt;a 模块依赖：查询网站http://www.rpmfind.net/ 包全名和包名 包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径 包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm中的数据库 RPM安装123456[root@localhost ~]# rpm -ivh h&gt; 选项：&gt; -i(install) 安装&gt; -v(verbose) 显示详细信息&gt; -h(hash) 显示进度&gt; --nodeps 不检测依赖性 升级123[root@localhost ~]# rpm -Uvh 包全名&gt; 选项&gt; -U(upgrade) 升级 卸载1234[root@localhost ~]# rpm -e 包名&gt; 选项&gt; -e(erase) 卸载&gt; --nodeps不检查依赖性 RPM包查询1234567891011121314151617181920212223242526[root@localhost ~]# rpm -q 包名# 查询包是否安装&gt; -q 查询(query)[root@localhost ~]# rpm -qa# 查询所有已经安装的RPM包&gt; -a 所有(all)[root@localhost ~]# rpm -qi 包名# 查询软件包详细信息&gt; -i 查询软件信息(information)&gt; -p 查询未安装包信息(package)[root@localhost ~]# rpm -ql 包名# 查询包中文件安装位置&gt; -l 列表(list)&gt; -p 查询未安装包信息(package)[root@localhost ~]# rpm -qf 系统文件名# 查询系统文件属于哪个RPM包&gt; -f 查询系统文件属于哪个软件包(file)[root@localhost ~]# rpm -qR 包名# 查询软件包的依赖性&gt; -R 查询软件包的依赖性(requires)&gt; -p 查询未安装包信息(package) RPM包默认安装位置 路径 释义 /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 RPM包校验123456[root@localhost ~]# rpm -V 已安装的包名# RPM包校验&gt; 选项&gt; -V 校验指定RPM包中的文件(verify)S.5....T. c /etc/httpd/conf/httpd/conf 验证内容中的8个信息的具体内容如下： S 文件大小是否改变 M 文件的类型或文件的权限(rwx)是否被改变 5 文件MD5校验和是否改变(可以看成文件内容是否改变) D 设备的主从代码是否改变 L 文件路径是否改变 U 文件的属主(所有者)是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 验证的文件类型 c 配置文件(config file) d 普通文件(documentation) g 鬼文件(ghost file), 很少见，就是该文件不应该被这个RPM包包含 L 授权文件(license file) r 描述文件(read me) RPM包中文件提取123[root@localhost ~]# rpm2cpio 包全名 | cpio -idv .文件绝对路径&gt; -rpm2cpio 将rpm包转换为cpio格式的命令&gt; -cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 cpio 12345[root@localhost ~]# cpio 选项 &lt; [文件|设备]&gt; 选项&gt; -i:copy-in模式，还原&gt; -d:还原时自动新建目录&gt; -v:显示还原过程]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_源码包安装]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——源码包安装 源码包与RPM包区别RPM包安装指定安装位置rpm --help|grep prefix 虽然可以指定安装路径，但是不建议这么做 源码包安装位置安装在指定位置当中，一般是 /usr/local/软件名 区别安装之前的区别：概念上的区别安装之后的区别：安装位置不同源码包通常运行效率会更好 源码包安装过程安装前准备 安装C语言编译器 gcc 下载源码包 安装前注意事项 源代码保存位置：/usr/local/src/ 软件安装位置：/usr/local/ 如何确定安装过程报错 安装过程停止 并出现error，warning或no的提示 源码包安装过程 下载源码包 解压缩下载的源码包 进入解压缩目录 执行./configure软件配置与检查定义需要的功能选项检测系统环境是否符合安装要求把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑例子：./configure --prefix=/usr/local/apache2 make 编译make clean make install编译安装 安装须知查看INSTALL文件(大部分人会写在这)]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_软件包管理]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——软件包管理 源码包 优点: 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 卸载方便 缺点: 安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境)，容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错，新手很难解决 脚本安装包：就是把复杂的软件包安装过程写成了程序脚本，初学者可以执行程序脚本实现一键安装。但实际安装的还是源码包和二进制包 优点是安装简单快捷 缺点是完全丧失了自定义性 二进制包（RPM包，系统默认包） 优点: 包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载 安装速度比源码包安装快很多 缺点： 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_YUM在线安装]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_YUM%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——YUM在线安装 文件目录/etc/yum.repos.d 默认文件 CentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo CentOS-Base.repo1234567[base]name=CentOS-$releaserver - Basemirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os#baseurl=http://mirror.centos.org/centos/$releasevver/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm=gpg/RPM-GPG-KEY=CentOS-6#上述中file后面`://`双斜杠代表的是协议的意思，即file协议 vi /etc/yum.repos.d/CentOS-Base.repo [base] 容器名称，一定要放在[]中 name 容器说明，可以自己随便写 mirrorlist 镜像站点，这个可以注释掉 baseurl 我们的YUM源服务器的地址，默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址 enabled 此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效 gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效 gpgkey 数字证书的公钥文件保存位置，不用修改 光盘搭建yum源挂载光盘1234#建立挂载点mkdir /mnt/cdrom#挂载光盘mount /dev/cdrom mnt/cdrom 使网络Yum源失效1234#进入yum源目录cd /etc/yum.repos.d/#修改yum源文件后缀名，使其失效mv CentOS-Base.repo CentOS-Base.repo.bak 使光盘Yum源生效vim CentOS-Media.repo 12345678[c6-media]name=CentOS-$releasever - Mediabasrurl=file://mnt/cdrom # 地址为你自己的光盘挂载地址# file:///media/cdrom# file:///media/cdrecorder # 注释这两个不存在的地址gpgcheck=1enabled=1 # 把enabled=0改为enabled=1，让这个yum源配置文件生效gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 Yum命令123456789101112131415161718192021222324252627282930313233343536373839# 查询所有软件包列表[root@localhost ~]# yum list# 搜索服务器上所有和关键字相关的包[root@localhost ~]# yum search 关键字# 安装命令[root@localhost ~]# yum -y install 包名 - 选项： &gt; install 安装 &gt; -y 自动回答yes[root@localhost ~]# yum -y install gcc # C语言编译器# 升级命令[root@localhost ~]# yum -y update 包名 - 选项： &gt; update 升级 &gt; -y 自动回答yes# 升级本服务器下所有的安装包，并且更新linux新内核，慎用，CentOS6.3及以前会有问题[root@localhost ~]# yum -y update# 卸载[root@localhost ~]# yum -y remove 包名 - 选项： - remove 卸载 - -y 自动回答yes# 服务器使用最小化安装，用什么软件安装什么，尽量不卸载# 列出所有可用的软件组列表[root@localhost ~]# yum grouplist# 安装指定软件组，组名可以由grouplist查询出来[root@localhost ~]# yum groupinstall 软件组名# 注意：软件组名必须是英文LANG=en_US # 修改语言，让显示的grouplist是英文列表# 卸载指定软件组[root@localhost ~]# yum groupremove 软件组名]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS根服务器模拟实验]]></title>
    <url>%2F2017%2F06%2F21%2FDNS-root_server-simulated%2F</url>
    <content type="text"><![CDATA[使用虚拟机模拟根服务器进行DNS解析 DNS访问的顺序 实现DNS转发模拟实验，需要6台虚拟机 VM IP 简称 C 172.18.51.12 12 S 172.18.51.13 13 根 172.18.51.14 14 com 172.18.51.15 15 主 172.18.51.16 16 从 172.18.51.17 17 配置思路顺序：主&gt;从&gt;com&gt;根&gt;S&gt;C 实验前请妥善备份好自己的配置文件，本实验需要配置变更目录为123456/etc/named.conf/var/named/named.ca/etc/named.rfc1912.zones/var/named/root.zone /com.zone /nigaha.com.zone 实验过程中可能需要的12345检查named.conf文件语法：named-checkconf [filename]检查区域配置文件语法：named-checkzone zone [filename]dig “域名” @IP 配置前为了放置中间出现意外首先确定关闭selinux，清空iptables，安装bind 一、在14中配置12345vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 让域内所有服务器知道自己是根服务器123456789vim /var/named/named.ca修改 ;; QUESTION SECTION: ;. IN NS ;; ANSWER SECTION: . 518400 IN NS a.root-servers.net. a.root-servers.net. 3600000 IN A 172.18.51.14下面多余部分删掉就可以不放心可以注释掉 分发/var/named/named.ca给所有主机13、15、16、171234scp /var/named/named.ca 172.18.51.17:/var/namedAre you sure you want to continue connecting (yes/no)? yesroot@172.18.51.17&apos;s password:named.ca 100% 478 0.5KB/s 00:00 在/etc/named.rfc1912.zones中配置根123456vim /etc/named.rfc1912.zones#添加zone &quot;.&quot; IN &#123; type master; file &quot;root.zone&quot;;&#125;; 在/etc/named.conf文件中有个根的指向需要删除123456vim /etc/named.conf#删除或注释掉下面内容# zone &quot;.&quot; IN &#123;# type hint;# file &quot;named.ca&quot;;# &#125;; 然后对com进行委派1234567891011121314vim /var/named/root.zone$TTL 86400 ; 1 day@ IN SOA dns1 admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1 #dns1是本机com NS dns2 #com指向dns2dns1 A 172.18.51.14 #本机地址dns2 A 172.18.51.15 #dns2指向com的ip 重启服务，7版本和6版本不一样 15中配置先修改配置,先建立com123456vim /etc/named.rfc1912.zones#添加zone &quot;com&quot; &#123; type master; file &quot;com.zone&quot;;&#125;; 创建com的域123456789101112131415161718vim /var/named/com.zone$TTL 86400 ; 1 day@ IN SOA dns1.nigaha.com. admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1nigaha NS dns2nigaha NS dns3dns1 A 172.18.51.15dns2 A 172.18.51.16dns3 A 172.18.51.16websrv A 172.18.51.111www CNAME websrv 如果com拥有从服务器的话dns1中ip必须为本机ip，不然不影响实验效果（另外需要再加条NS记录指向从服务器也就是dns3，如果不加不影响效果，但是你要的从服务器就没卵用了）注意！！！重启服务 套路有点不对，现在配主从服务器 二、在16中配置在“options”的段里1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 配置域1234567#添加vim /etc/named.rfc1912.zoneszone &quot;nigaha.com&quot; &#123; type master; file &quot;nigaha.com.zone&quot;;// allow-transfer &#123; any;&#125;; #这个可以忽略&#125;; 创建区域数据文件1234567891011121314151617vim /var/named/nigaha.com.zone$TTL 86400 ; 1 day@ IN SOA dns1.nigaha.com. admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1.nigaha.com. NS dns2.nigaha.com.dns1 A 172.18.51.14dns2 A 172.18.51.17websrv A 172.18.51.14www CNAME websrv 三、在17中配置在“options”的段里1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 配置域123456#添加zone &quot;nigaha.com&quot; &#123; type slave; masters &#123;172.18.51.16; &#125;; file &quot;slaves/nigaha.com.slaves.zone&quot;;&#125;; 看看有木有域数据文件呀12cd /var/named/slaves;lsnigaha.com.slaves.zone 四、在13中配置先确定下根在不在12345678vim /var/named/named.ca;; QUESTION SECTION:;. IN NS;; ANSWER SECTION:. 518400 IN NS a.root-servers.net.a.root-servers.net. 3600000 IN A 172.18.51.14 #对的就是他！ 查看配置文件/ect/named.conf1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 重启服务！重启服务！重启服务！ 五、在12号验证123456789101112131415161718192021222324252627dig www.nigaha.com @172.18.51.13; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &lt;&lt;&gt;&gt; www.nigaha.com @172.18.51.13;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59258;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 2;; QUESTION SECTION:;www.nigaha.com. IN A;; ANSWER SECTION:www.nigaha.com. 86400 IN CNAME websrv.nigaha.com.websrv.nigaha.com. 86400 IN A 172.18.51.14;; AUTHORITY SECTION:nigaha.com. 86400 IN NS dns1.nigaha.com.nigaha.com. 86400 IN NS dns2.nigaha.com.;; ADDITIONAL SECTION:dns2.nigaha.com. 86400 IN A 172.18.51.17dns1.nigaha.com. 86400 IN A 172.18.51.14;; Query time: 11 msec;; SERVER: 172.18.51.13#53(172.18.51.13);; WHEN: Mon Sep 25 10:52:43 2017;; MSG SIZE rcvd: 139 成功！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DNS</tag>
        <tag>服务servers</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建静态博客]]></title>
    <url>%2F2017%2F05%2F21%2Fgithub%2Bhexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo从开始到搭建成功 本篇所包含的内容如下： 安装Git Bash 安装NodeJs 安装hexo 生成SSH并添加到github 部署项目 上传到github 绑定个人域名 修改及配置主题 添加RSS 添加评论 写文章部分 1. 安装Git Bash首先准备好Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。 下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用。 下载地址(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量） 查看版本： 命令：node -v 3. 安装hexogitbash中用npm工具安装。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo 安装完成后，查看版本： 命令：hexo -v 初始化命令：hexo init 在你的目录会出现(master) 解释一下目录中文件作用： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 主要在_config.yml目录中进行配置，其他的目录不需要做太大改动。 4. 搭桥到github​ github网址 没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称。 回到gitbash中，配置github账户信息 创建SSH密钥在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。找到id_rsa.pub文件的内容。（记住密码，生成的密钥一般都在本地C盘user目录中） 将上面获取的ssh放到github中：添加一个 New SSH key ，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com（可以不做） 5. 配置主目录 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令： 123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装： 1npm i hexo-server 打开浏览器输入：http://localhost:4000 6. 上传到github 先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)： 123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： ​提示： INFO Deploy done: git信息部署完成 在浏览器中输入http://yourgithubname.github.io 如果再次推送的话hexo s本地测试无误后，使用hexo deploy就可以 7. 绑定个人域名可选 第一步购买域名：阿里云、腾讯云。DNS顺便弄了 第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是nigaha.com。 到DNS中添加记录：其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)： 8. 修改及配置主题 hexo初始化之后默认的主题是landscape , 想更换其他主题请点击更多hexo主题地址。在Search中搜索你要的主题名称。 跟该主题相关的配置在themes/hueman/_config.yml 在导航栏添加点东西 例如添加了一个更新日志的模块。 在主题的配置文件中，menu添加一栏：Board: /board。 然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。 在主题的hueman/langulages/zh-CN.yml中的index适当的位置加：board: &#39;更新日志&#39;，位置和名字是你自己设定。 重新部署，然后就OK了 在侧边栏添加点东西 回到你的主题的配置文件中，找到widgets一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫communiation且放在了第二行。 在上面所提到的zh-CN.yml文件中找到sidebar一栏，添加communiation: &#39;你要设的名称&#39;。 在hueman/layout/widget中添加一个communiation.ejs,填入模板 12345678&lt;% if (site.posts.length) &#123; %&gt;&lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;sidebar.communiation&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!--这里添加你要写的内容--&gt; &lt;/div&gt;&lt;/div&gt;&lt;% &#125; %&gt; 9. 添加RSS 先安装rss相关插件：npm i hexo-generator-feed 在你的项目的_config.yml配置文件下找到Extensions添加如下内容： 1234567891011# Extensions #插件和主题## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。 重新部署再打开就能看到效果啦~ 10. 添加评论20170812更新：云更贴已在2017年8月1日停止服务，具体评论系统文章统计站长统计及百度SEO谷歌SEO什么的可参考Hexo博客添加SEO-评论系统-阅读统计-站长统计-—-此段已失效。 先选一个你要使用的第三方评论系统。 在主题的配置文件下找到comment，添加一行，例如我添加的是yungentie: 此处自由发挥 注册完评论系统后获取相应的代码，然后在主题的layout下找到comment新建一个ejs模板文件，名称自定义。 找到你的article.ejs模板文件，加上&lt;%- partial(&#39;comment/你刚刚取得名字&#39;) %&gt;保存。 重新部署，OK啦 11. 文章部分 新建文章：hexo new &#39;文章名&#39;，然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。 关于具体的文章编辑你可以看下官网的介绍 markdown很容易上手]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用vim技术总结]]></title>
    <url>%2F2017%2F05%2F21%2Fvim%E5%B8%B8%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[vim编辑器常用总结 vim 编辑器文本编辑器：字处理器ASCII vi : Visual Interfacevim : VI iMproved 全屏编辑器：模式化编辑器 vim 模式 编辑模式（命令模式、普通模式、默认模式） 输入模式 末行模式 模式转换： 编辑–&gt;输入 字符： i：在当前光标所在字符前，转为输入模式 a: 在当前光标所在字符后，转为输入模式 行： I: 在当前光标所在行首，转为输入模式 A：在当前光标所在行尾，转为输入模式 o：在当前光标所在行下方，转为输入模式 O：在当前光标所在行上方，转为输入模式 输入–&gt;编辑： Esc键 编辑–&gt;末行： ： 末行–&gt;编辑： Esc键 一、打开文件# vim /path/to/somefile 打开之前父目录须存在，否则就是创建文件 打开后左下角显示： 文件名 行数 字符数量 打开后右下角显示： 目前所在位置 行首或行尾 # vim +12 inittab : 进入后直接进入#行 # vim + inittab : 进入后直接进入行尾 # vim +/PATTERN : 打开文件，定位至第一次呗’PATTERN’匹配到的行首 二、关闭文件1、末行模式关闭文件 :q 退出 :wq 保存退出 :q! 不保存并退出 :w 保存 :w! 强行保存 :wq!强行保存退出 :x 保存退出 2、编辑模式下退出 ZZ 保存并退出 当文件被修改，无论是否还原之前样子都是修改后文件。不保存退出即可 三、移动光标（编辑模式）移动键+数字 可以移动多个字符1、逐字符移动 h:左 j:下 k:上 l:右 2、以单词为单位移动 w：移至下一个单词的词首 e：跳至当前或下一个单词的词尾 b：跳至当前或前一个单词的词首 3、行内跳转： 0：绝对行首 ^：移动至第一个非空白字符 $：绝对行尾 4、行间跳转： #G:跳转到第#G行 G：最后一行 末行模式下，直接给出行号即可 四、翻屏 Ctrl+f：向下翻一屏 Ctrl+b：向上翻一屏 Ctrl+d：向下翻半屏 Ctrl+u: 向上翻半屏 五、删除单个字符 x: 删除光标所在处单个字符 #x: 删除光标所在处及向后的共#个字符 六、删除命令（d）：数字+dd删除 光标下的数字行 d 命令可以跟跳转命令组合使用 例： d$ 删除至行尾 d0 删除至行首 dw 删除单词 de 删除至下个单词 db 删除至上个单词 dd 删除行 末行模式下： StartADD,EndADDd 例：（.：表示当前行） :1,8d（从1行至8行删除） :.,+5d（从当前行到向下5行删除） :.,$-3d（从当前行到倒数第3行删除） 七、复制命令（y）： 用法和d命令一样 八、修改：先删除内容，在转换为输入模式 c：用法同d命令 九、粘贴命令（p）： p： `删除或复制行为整行，则粘贴至光标下方行；删除或复制行为非整行，则粘贴至光标后面；` P： `删除或复制行为整行，则粘贴至光标上方行；删除或复制行为非整行，则粘贴至光标前面；` 十、替换（r）：经常使用在单个字符替换 R：替换模式 十一、撤销编辑操作（u）：默认可以撤销50次 u：撤销前一次的编辑操作 连续u命令可以撤销此前的n次操作 #u：直接撤销最近#次编辑操作 Ctrl+r：还原上一次的撤销操作 十二、重复前一次编辑操作 . 十三、可视化模式 v：按字符选取 V：按矩形选取 十四、查找 /PATTERN ?PATTERN n：下一个 N：上一个 十五、查找并替换在末行模式下使用sed命令s@@@用法同d命令类似，仅是将d命令换成s@@@命令 1，$：第一行至最后一行 %：表示全文 练习：将’/etc/yum.repos.d/server.repo文件中的ftp://instructor.example.com/pub替换为http://172.18.0.1/yum‘1%s/ftp:\/\/instructor\.example\.com\/pub/http://172.18.0.1\/yum/gi 十六、使用vim打开多个文件vim FILE1 FILE2 … :next 切换至下一个文件 :prev 切换至上一个文件 :last 切换至最后一个文件 :first 切换至第一个文件退出 :qa 退出全部文件 十七：分屏显示一个文件 Ctrl+w，s : 水平拆分窗口 Ctrl+w，v : 垂直拆分窗口 在窗口间切换光标： Ctrl+w，ARROW（箭头） 退出 :qa 退出全部文件 十八、分窗口多个文件 vim -o FILE1 FILE2 : 水平分割显示 vim -O FILE1 FILE2 : 垂直分割窗口例：vim -o rc.sysinit inittab 十九、将当前文件中部分内容另存为另外一个文件末行模式下使用w命令 :w：保存内容 :w /path/to/somefile 保存内容到指定文件中:ADDR1,ADDR2w /path/to/somefile 将指定行内容保存到指定文件中 二十、将另外文件内容填充在当前文件中 :r /path/to/somefile默认是将填充内容放置在光标下行 二十一、跟shell交互 :!COMMAND 二十二、特殊用法1、显示或取消行号 显示行号 :set number :set nu 取消显示行号 :set nonu 行号并非文件内容，是编辑自带显示功能，默认并不是永久存在 2、显示忽略或区分字符大小写 忽略大小写 :set ignorecase :set ic 取消忽略大小写 :set noignirecase :set noic 3、设定自动缩进 自动缩进 :set autoindent :set ai 取消自动缩进 :set noautoindent :set noai 4、查找到的字符高亮显示 高亮 :set hlsearch 取消高亮 :set nohlsearch 5、语法高亮 高亮 :syntax on 取消高亮 :syntax off 二十三、配置文件/etc/vimrc 全局配置文件~/.vimrc 当前用户配置文件（如果没有可以自行创建） 二十四、vimtutorvim学习文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash简单脚本]]></title>
    <url>%2F2017%2F04%2F25%2Fbash_if%E8%AF%AD%E5%8F%A5%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[bash基本if语句结构 面向过程 控制结构 顺序结构 选择结构 循环结构 选择结构： if语句： 单分支、双分支、多分支 单分支语句1234if CONDITION;then statement ...fi 双分支语句1234567if CONDITION;then statement ...else statement1 ...fi 多分支语句(这种多分支效率要低)12345678910111213if CONDITION;then statement ...elif statement1 ...elif statement2 ...else statement3 ...fi case语句：123456789101112131415case SWITCH invalue1) statement ... ;;value2) statement ... ;;*) statement ... ;;esac` 字符测试： [ $A = $B ] 等号两边都需要加空格，不然会被认为是附值。 == : 测试是否相等，相等为真，不等为假 != : 测试是否不等，不等为真，相等为假 > : 大于 &lt; : 小于 -n string ： 测试指定字符串是否为空，空则真，不空则假 -s string ： 测试指定字符串是否为不空，不空为真，空则为假 脚本练习：传递一个用户名参数给脚本，判断此用户的用户名跟其基本组的组名是否一致，并将结果显示出来。123456789101112#!/bin/bash#if ! id $1 &amp;&gt;/dev/null; then echo &quot;No such user&quot; exit 10fi if [ &apos;id -n -u $1&apos; == &apos;id -n -g $1&apos; ]; then echo &quot;yiyang&quot;else echo &quot;buyiyang&quot;fi 传递一个参数（单个字符）给脚本，如参数为q、Q、quit、Quit，就退出脚本，否则，就显示用户的参数；1234567891011121314151617#!/bin/bash#if [ $1 = &apos;q&apos; ];then echo &quot;Quiting...&quot; exit 1elif [ $1 = &apos;Q&apos; ];then echo &quot;Quiting...&quot; exit 2elif [ $1 = &apos;quit&apos; ];then echo &quot;Quiting...&quot; exit 3elif [ #1 = &apos;Quit&apos; ];then echo &quot;Quiting...&quot; exit 4else echo $1fi 可以使用&amp;&amp;来进行判断 传递三个参数给脚本，第一个为整数，第二个为算出运算符，第三个为整数，将计算结果显示出来，要求保留两位精度。形如： ./calc.sh 5 / 2提示：bc命令echo “scale=2;111/22;” | bc(保留2位小数，111/2)同样可以：bc &lt;&lt;&lt; “scale=2;111/22;” 传递3个参数给脚本，参数均为用户名。将此些用户的帐号信息提取出来后放置于/tmp/testusers.txt文件中，并要求每一行行首有行号。 echo “1 $LINE” &gt;&gt; /tmp/testusersecho “2 $LINE” &gt;&gt; /tmp/testusers 脚本需求：判断当前主机的CPU生产商，其信息在/proc/cpuinfo文件中vendor id一行中。如果其生产商为AuthenticAMD,就显示其为AMD公司；如果其生产商为GenuineIntel,就显示其为Intel公司；否则，就说其为非主流CPU公司；123456789#!/bin/bash#CPU=`grep &apos;Vendor_id&apos; /proc/cpuinfo |cut -d: -f2`if [ $CPU == AuthenticAMD ];then echo &quot;The CPU is AMD&quot;elif [ $CPU == GenuineIntel ];then echo &quot;The CPU is Intel&quot;else echo &quot;Unkown&quot; 写一个脚本：生成10个随机整数，判断其中的最大数和最小数，并显示出来。MAX=0MAX -eq $1MAX=$1MAX -lt $2MAX=$2 123456789101112131415161718#!/bin/bash#declare -i MAX=0declare -i MIN=0for I in &#123;1..10&#125;;do MYRAND=$RANDOM [ $I -eq 1 ] &amp;&amp; MIN=$MYRAND if [ $I -le 9 ];then echo -n &quot;$MYRAND&quot; else echo &quot;$MYRAND&quot; fi [ $MYRAND -gt $MAX ] &amp;&amp; MAX=$MYRAND [ $MYRAND -lt $MIN ] &amp;&amp; MIN=$MYRANDdoneecho $MAX,$MIN 循环：循环控制结构进入条件，退出条件常用循环： for while until1234for: for 变量 in 列表;do 循环体 done 当列表被遍历完成之后，退出；123for I in 1 2 3 4 5 6 7 8 9;do 加法运算done 生成列表：数字列表: ｛1..100｝ 也可以使用 seq 命令生成 seq 命令： ‘seq [起始数 [步进长度]] 结束数’ 起始数省略后默认起始数为’1’ 步近长度省略后默认步进长度为’1’ 文件名列表： 例如： ‘ls /etc’ declare 声明： declare -i SUM=0(声明SUM为0的整数) -i : integer(整数) declare -x -x : (环境) 求1,..,100之和；123456789#!/bin/bash#declare -i SUM=0for I in &#123;1..100&#125;;do let SUM=$[$SUM+$I]doneecho &quot;The sum is: $SUM&quot; 添加10个用户user1到user10，密码同用户名；但要求只有用户不存在的情况下才能添加；123456789101112131415161718192021222324252627#!/bin/bash#for I in &#123;1..10&#125;; do if id user$I &amp;&gt; /dev/null; then echo &quot;user$I exists&quot; else useradd user$I echo user$I | passwd --stdin user$I &amp;&gt; /dev/null echo &quot;add user user$I finished&quot; fidone#删除10个用户#!/bin/bash#for I in &#123;1..10&#125;; do if id user$I &amp;&gt; /dev/null; then userdel -r user$I echo &quot;delete user$I finished&quot; else echo &quot;user$I not exists&quot; fidone 给定脚本参数，如果是–add则添加10个用户，如果是–del则删除10个用户12345678910111213141516171819202122232425262728293031#!/bin/bash#if [ $# -lt 1 ]; then echo &quot;Usage:adminusers ARG&quot; exit 3fiif [ $1 == &apos;--add&apos; ]; then for I in &#123;1..10]; do if id user$I &amp;&gt; /dev/null; then echo &quot;user$I exists&quot; else useradd user$I echo user$I | passwd --stdin user$I &amp;&gt; /dev/null echo &quot;add user$I finished&quot; fi doneelif [ $1 == &apos;--del&apos; ]; then for I in &#123;1..10&#125;; do if id user$I &amp;&gt; /dev/null; then userdel -r user$I echo &quot;delete user$I finished&quot; else echo &quot;no user$I&quot; fi doneelse echo &quot;Unknown ARG&quot; exit 4fi 指定使用–add USER1，USER2，ABC，tom；如果不存在则添加用户USER1，USER2，ABC，tom；并显示添加成功；同样使用–add USER1，USER2，ABC，tom；如果存在则删除用户USER1，USER2，ABC，tom；并显示删除成功；同时给予–help帮助信息1234567891011121314151617181920212223242526272829303132#!/bin/bash#if [ $# -lt 1 ]; then echo &quot;Usage:yyuser ARG&quot; exit 3fiif [ $1 == &apos;--add&apos; ]; then for I in `echo $2 | sed &apos;s/,/ /g&apos;`; do if id $I &amp;&gt; /dev/null; then echo &quot;$I exists&quot; else useradd $I echo $I | passwd --stdin $I &amp;&gt; /dev/null echo &quot;add $I finished&quot; fi doneelif [ $1 == &apos;--del&apos; ]; then for I in `echo $2 | sed &apos;s/,/ /g&apos;`; do if id $I &amp;&gt; /dev/null; then userdel -r $I echo &quot;delete $I finished&quot; else echo &quot;$I not exist&quot; fi doneelif [ $1 == &apos;--help&apos; ]; then echo &quot;Usage: yyuser.sh --add USER1,USER2,... | --del USER1,USER2,... | --help&quot;else echo &quot;Unknown options&quot;fi]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed使用方法]]></title>
    <url>%2F2017%2F04%2F24%2Fbash_sed%2F</url>
    <content type="text"><![CDATA[三剑客之sed sed 命令sed：Stream EDitor 行编辑器（全屏编辑器：vi） sed：模式空间 默认比编辑原文件，仅对模式空间的数据做处理； 处理结束后，将模式空间打印至屏幕； sed [options] ‘AddressCommand’ file … 地址命令中间不需要空白字符可以直接写 对于file中的复合地址指定范围内的行，执行相应命令[options]: -n: 静默模式，不再默认显示模式空间中的内容 -i: 直接修改原文件（慎用） -e SCRIPT -e SCRIPT : 可以同时执行多个脚本 -f /PATH/TO/SED_SCRIPT ：使用脚本的文件路径来对文件进行处理 sed -f /path/to/scripts file -r: 表示使用扩展正则表达式 Address:1、StartLine,EndLine（从起始行到结束行，中间逗号） 例如1,100 $:最后一行2、/RegExp/（使用正则表达式指定的模式） 例：/^root/3、/pattern1/,/pattern2/ 第一次被pattern1匹配到的行开始，至第一次被pattern2匹配到的行结束，这中间的所有行4、LineNumber 指定的行5、StratLine,+N 从StartLine开始，向后的N行； Command: d:删除符合条件的行 例： sed ‘1,2d’ /etc/fstab sed ‘3,$d’ /etc/fstab sed ‘/oot/d’ /etc/fstab sed ‘1,+2d’ /etc/fstab sed ‘1d’ /etc/fstab p:显示打印符合条件的行（因为处理过后模式空间会保留内容，所以p打印出的结果为2次） 例： sed ‘/^\//p’ /etc/fstab a \string: 在指定的行后面追加新行，内容为string 例： sed ‘/^\//a # hello word’ /etc/fstab sed ‘/^\//a # hello word\n# hello linux’ /etc/fstab \n：可以用于换行 i \string: 在指定的行前面添加新航，内容为string （使用方法和a类似）r filename:将指定的文件内容添加至符合条件的行处 例： sed ‘$r /etc/issue’ /etc/fstab 此命令可以用于合并文件使用，这个和cat命令连续读取2个文件的效果是一样的，sed可以中间插入。 sed ‘1,2r /etc/issue’ /etc/fstab （在2行插入）w filename:将地址指定范围内的内容另存至指定的文件中 例： sed ‘/oot/w /tmp/oot.txt’ /etc/fstabs/pattern/string/ 修饰符: 也可以写成s/// s@@@ s### （pattern模式可以使用正则表达式，string被替换不可以） （默认只替换每行中第一次被模式匹配到的字符串） 修饰符： g:全局替换 i：查找时忽略大小写 例： sed ‘s/oot/OOT/‘ /etc/fstab sed ‘s/^\//#/‘ /etc/fstab 后项引用()，\1，\2 例： 文本内容sed.txt，将”l..e”的字符后面增加字母”r” hello,like hi, my love 后项引用 sed ‘s#(l..e)#\1r#g’ sed.txt 可以使用sed的替换法： sed ‘s#^l..e$#&amp;r# sed.txt &amp;：引用模式匹配整个串 练习：123456789101112131415161718192021222324252627282930将history打印结果中所有空白删除history | sed &apos;s#^[[:space:]]*##g&apos; | cut -d&apos; &apos; -f1 1、删除/etc/grub.conf文件中行首的空白符； sed -r &apos;s@^[[:spapce:]]+@@g&apos; /etc/grub.conf 2、替换/etc/inittab文件中&quot;id:3:initdefault:&quot;一行中的数字为5; sed -r &apos;s@\(id:\)[0-9]\(:initdefault:\)@\15\2@g&apos; /etc/inittab 3、删除/etc/inittab文件中的空白行； sed -r &apos;/^$/d&apos; etc/inittab4、删除/etc/inittab文件中开头的#号； sed -r &apos;s@^#@@g&apos; /etc/inittab5、删除某文件中开头的#号及后面的空白字符，但要求#号后面必须有空白字符； sed -r &apos;s@^#[[:space:]]+@@g&apos; 6、删除某文件中以空白字符后面跟#类的行中的开头的空白字符及# sed -r &apos;s@^[[:space:]]+#@@g&apos;7、去除一个文件路径的目录名称； echo &quot;/etc/rc.d/&quot; | sed -r &apos;s@^(/.*/)[^/]+/?@\1@g&apos; 基名： echo &quot;/etc/rc.d/&quot; | sed -r &apos;s@^/.*/([^/]+)/?@\1@g&apos;某文件：#abc# hello # hi# he]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>三剑客</tag>
        <tag>bash</tag>
        <tag>正则表达式</tag>
        <tag>文本工具</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash组合条件判断]]></title>
    <url>%2F2017%2F04%2F23%2Fbash_%E7%BB%84%E5%90%88%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[bash组合条件判断 使用脚本选项及组合条件测试 测试：整数比较： -eq 相等 -ne 不等 -gt 大于 -lt 小于 -ge 大于等于 -le 小于等于 文件测试： -e FILE: 测试文件是否存在 -f FILE: 测试文件是否为普通文件 -d FILE: 测试指定路径是否为目录 -r FILE: 测试当前用户对指定文件是否有读取权限 -w FILE: 测试当前用户对指定文件是否有写入权限 -x FILE: 测试当前用户对指定文件是否有执行权限 字符测试：[ $A = $B ] 等号两边都需要加空格，不然会被认为是附值。 == : 测试是否相等，相等为真，不等为假 != : 测试是否不等，不等为真，相等为假 > : 大于 &lt; : 小于 -n string ： 测试指定字符串是否为空，空则真，不空则假 -s string ： 测试指定字符串是否为不空，不空为真，空则为假 组合测试条件： -a：与关系 -o：或关系 !：非关系 用户给的参数是否大于1并且小于3；if [ $# -gt 1 -a $# -le 3 ]if [ $# -gt 1 ] &amp;&amp; [ $# -le 3 ] 用户输入：q、Q、quit、Quit；其结果为退出，输入其他为无法识别参数；123456789#!/bin/bash#if [ $1 == &apos;q&apos; -o $1 == &apos;Q&apos; -o $1 == &apos;Quit&apos; -o $1 == &apos;quit&apos; ]; then echo &quot;Quiting...&quot; exit 0else echo &quot;Unknown Argument.&quot; exit 1fi 附值表达式：将一个变量的值经过运算还保存回这个变量的空间当中去 -= += *= /= %=：取模等于（一个变量等于在他自身以后取模再放回这个变量，例：14对3取模值为2）123456789例如： 某个变量等于自身加某个其他变量可以使用+=$I let SUM+=$I let I=$[$I+1] SUM=$[$SUM+$I] let I+=1 相当于 let I++let I-=1 相当于 let I-- 计算100以内所有奇数之和以及所有偶数之和；分别显示12345678910111213141516#!/bin/bash#declare -i EVENSUM=0declare -i ODDSUM=0for I in &#123;1..100&#125;;do if [ $[$I%2] -eq 0 ];then let EVENSUM+=$I else let ODDSUM+=$I fidoneecho &quot;Odd sum is:$ODDSUM&quot;echo &quot;Even sum is:$EVENSUM&quot;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash条件判断]]></title>
    <url>%2F2017%2F04%2F23%2Fbash_shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[bash条件判断，脚本基础语句使用 bash 条件判断 如果用户不存在 添加用户，给密码并显示添加成功 否则(目标存在) 显示如果已经存在，没有添加 bash脚本语法检测： bash -n filetest.shbash脚本单步执行显示： bash -x filetest.sh bash 中如何实现条件判断条件判断测试类型 整数测试: A是否为6,$A是否为6 字符测试： 变量保存是否为A、B、C、D 文件测试： 判断一个文件是否存在 条件测试的表达式描述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 [ expression ] bash命令 [[ expression ]] bash关键字 test expression text命令INT1=66INT2=99[ $INT1 -eq $INT2 ][[ $INT1 -eq $INT2 ]]test $INT1 -eq $INT2``` 整数比较：* -eq 相等* -ne 不等* -gt 大于* -lt 小于* -ge 大于等于* -le 小于等于字符测试：[ $A = $B ] 等号两边都需要加空格，不然会被认为是附值。* == : 测试是否相等，相等为真，不等为假* != : 测试是否不等，不等为真，相等为假* \&gt; : 大于* &lt; : 小于* -n string ： 测试指定字符串是否为空，空则真，不空则假* -s string ： 测试指定字符串是否为不空，不空为真，空则为假文件测试：* -e FILE: 测试文件是否存在* -f FILE: 测试文件是否为普通文件* -d FILE: 测试指定路径是否为目录* -r FILE: 测试当前用户对指定文件是否有读取权限* -w FILE: 测试当前用户对指定文件是否有写入权限* -x FILE: 测试当前用户对指定文件是否有执行权限 [ -e /etc/inittab ][ -x /etc/rc.d/rc.sysinit ]组合测试条件：* -a：与关系* -o：或关系* !：非关系命令间的逻辑关系：- 逻辑或（||）：如果前面真，后面不判断 * 如果前面假，后面必须判断- 逻辑与（&amp;&amp;）：如果前面假，后面不判断 * 如果前面真，后面必须判断 - 例：id user1 &amp;&gt; /dev/null &amp;&amp; echo &quot;Hello,deny&quot; - 扩展：如果用户不存在，就添加用户(user2) * ! id user2 &amp;&gt; /dev/null &amp;&amp; useradd user2 * id user2 &amp;&gt; /dev/null || useradd user2 exit可以直接突出当前脚本，并赋予一条执行状态- exit number（数值在0~255之间，0为成功，其他为不成功） 注意：- 脚本结束变量就会撤销（变量的好处就是一次性修改能够应用到整个程序中）；- 如果脚本没有明确定义退出状态码，那么，最后执行的命令的退出码即为脚本的退出状态码；bash 变量的类型：- 本地变量：当前shell工作的进程- （局部变量）- 环境变量：当前shell及其子shell- 位置变量： * $1,$2,...（位置变量$1就是脚本中的第一个参数） * shift（轮换）- 特殊变量： * $? * $#:参数的个数 * $*:参数列表 * $@:参数列表命令：修正文件执行特性参数：命令的作用对象变量名称规则：- 1.只能包含字母、数字和下划线，并且不能数字开头； - 2.不应该根系统中已有的环境变量重名；- 3.见名知意 #！/bin/bash #要引用命令的返回结果要使用命令替换 #把wc命令的结果保存在LINES变量当中LINES=wc -l /etc/inittab #echo $LINES #执行结果为 53 /etc/inittabFINLINES=echo $LINES | cut -d &#39; &#39; -fi #echo $FINLINES #执行结果为 53[ $FINLINES -gt 100 ] &amp;&amp; echo “/etc/inittab is a big file” || echo “/etc/inittab is a small file” #[ $FINLINES -gt 100 ] &amp;&amp; echo “/etc/inittab is a big file”的结果为假 #执行结果为空 #之后的判断就是：假 || echo “/etc/inittab is a small file” #输出结果为：/etc/inittab is a small file #总结：当&amp;&amp;判断得出的结果为假时，则执行 || 的判断输出。 #同时，当&amp;&amp;判断得出的结果为真时，则不执行 || 判断12345678910111213同理如果用户存在，就显示用户已存在。否则，就添加此用户。- id user1 &amp;&amp; echo &quot;user1 exists&quot; || useradd user1如果用户不存在，就添加此用户。否则，显示其已经存在。- ! id user1 &amp;&amp; useradd user1 || echo &quot;user1 exists&quot;如果用户不存在，添加用户并给予密码。否则，显示其已经存在。- ! id user1 &amp;&amp; useradd user1 &amp;&amp; echo &quot;user1&quot; | passwd --stdin user1 || echo &quot;user1 exists&quot;练习：1、添加3个用户user1、user2、user3，但要求先判断用户是否存在，不存在而后再添加2、显示当前系统上共有多少个用户 #!/bin/bash! id user1 &amp;&gt; /dev/null &amp;&amp; useradd user1 &amp;&amp; echo “user1” | passwd –stdin user1 &amp;&gt; /dev/null || echo “user1 exists”! id user2 &amp;&gt; /dev/null &amp;&amp; useradd user2 &amp;&amp; echo “user2” | passwd –stdin user2 &amp;&gt; /dev/null || echo “user2 exists”! id user3 &amp;&gt; /dev/null &amp;&amp; useradd user3 &amp;&amp; echo “user3” | passwd –stdin user3 &amp;&gt; /dev/null || echo “user3 exists” USERS=wc -l /etc/passwd | cut -d: -f1echo “$USERS users”123练习：1、如果用户UID为0，显示其为管理员2、否则，显示其为普通用户 #!/bin/bashNAME=root #NAME=user1USERID=id -u $NAME[ $USERID -eq 0 ] &amp;&amp; echo “Admin” || echo “Common user”1条件判断，控制结构 要求： 如果if和then在同一行必须写为 if [[ condition ]]; then - #statements fi 也可以写为 if [[ condition ]] then #statements fi 1单分支if语句 if 判断条件； then #如果判断条件为真，则then执行后面语句 语句1 #语句statement 语句2 #单分支语句如果不满足，就略过不会继续执行 。。。fi1双分支的if语句 if 判断条件； then #如果判断条件为真，则then执行后面语句 语句1 语句2 。。。else #如果判断条件为假，则else执行后面语句 语句3 语句4 。。。fi1多分支的if语句 if 判断条件1； then statement1 。。。elif 判断条件2； then statement2 。。。elif 判断条件3； then statement3 。。。else statement4 。。。fi1234练习：查看用户user17是否存在，存在在屏幕显示。否则创建并添加密码，并通知创建成功。 #!/bin/bashNAME=user17 if id $NAME &amp;&gt; /dev/null; then echo “$NAME exists”else useradd $NAME echo $NAME | passwd –stdin $NAME &amp;&gt; /dev/null echo “Add $NAME finished”fi123练习：1、如果用户UID为0，显示其为管理员2、否则，显示其为普通用户 #!/bin/bashNAME=root #NAME=user1USERID=id -u $NAME#if [ $USERID -eq 0 ]; then echo “Admin”else echo “Common user”fi 也可以 NAME=root #NAME=user1#if [ id -u $NAME -eq 0 ]; then echo “Admin”else echo “Common user”fi12345678910111213141516#`id -u $NAME`为执行结果# 例：id -u user1# 其执行结果为1001，所以用单引号引起#id $NAME为状态结果# 例：echo $?# 其状态结果为1或者0#所以本题中使用的是查看执行结果进行比较在bash中，要引用一个命令是否能够执行成功，想要引用这个命令的状态结果一定不能加引号要么让其执行成功（状态结果），要么取其执行状态结果$?练习：判断当前系统上是否有用户的默认shell为bash： 如果有，就显示其中一个用户名； 否则就显示没有此类用户； #!/bin/bash#grep “\&lt;bash$” /etc/passwd &amp;&gt; /dev/nullRETVAL=$? if [ $RETVAL -eq 0 ]; then AUSER=`grep “\&lt;bash$” /etc/passwd | head -l | cut -d: -f1’ echo “$AUSER is one of such users.”else echo “No such user”fi1234练习：给定一个文件，比如/etc/inittab，判断此文件中是否有空白行： 如果有，则显示其空白行数； 否则，显示没有空白行； #!/bin/bash#FILE=/etc/inittabif [ ! -e $FILE ]; then echo “No $FILE” exit 1fi KH=grep &#39;^$&#39; /etc/inittab | wc -lif [ $KH -gt 0 ]; then echo “$KH”else echo “没有空白行”fi1234练习：给定一个用户，判断其UID与GID是否一样 如果相同，就显示此用户为&quot;good guy&quot;； 否则，就显示此用户为&quot;bad guy&quot;； #!/bin/bash#username=user1userID=id -u $USERNAMEgroupID=id -g $USERNAMEif [ $userID -eq $groupID ]; then echo “good guy”else echo “bad guy”fi1进一步要求：不使用id命令获取其id号； #!/bin/bash#USERNAME=user1if ! grep “^$USERNAME>“ /etc/passwd &amp;&gt; /dev/null; then echo “No such user：$USERNAME” exit 1fi userID=grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f3groupID=grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f4if [ $userID -eq $groupID ]; then echo “good guy”else echo “bad guy”fi1234567891011121314151617181920212223242526练习：给定一个用户，获取其密码警告期限，然后判断用户最近一次修改密码时间距其最长使用期限是否小于警告期限； 提示：算出运算的方法$[$A-$B]:表示变量A的值减去变量B的值的结果； 如果小于，则显示&quot;warning&quot;； 否则，就显示&quot;OK&quot;；帮助命令： bc date +%s ### shell中如何使用算数运算 A=3 B=6 使用算数运算表达式进行计算- let命令： * let C=$A+$B - $[算数运算表达式] * C=$[$A+$B]- $((算数运算表达式)) * C=$(($A+$B)) - expr 算术运算表达式，表达式中个操作数及运算符之间要有空格，而且要使用命令引用 * C=`expr $A + $B` 圆整：丢弃小数点后面数字，取得整数 在此取得的时间戳都会进行圆整 TIMESTAMP=’date +%s’let THEDAYTIME=$TIMESTAMP/86400echo $THEDAYTIME # 1970到现在天数 #!/bin/bash#W=grep &quot;student&quot; /etc/shadow | cut -d: -f6S=date +%sT=expr $S/86400L=grep &quot;^student&quot; /etc/shadow | cut -d: -f3SY=$[$L-$[$T-$N]] if [ $SY -lt $W ]; then echo ‘worning’else echo ‘OK’fi123练习：判定命令历史中的历史命令的总条目是否大于1000； 如果大于，则显示&quot;some command will gone&quot;； 否则显示&quot;OK&quot; #！/bin/bash#HISTORY=’history | tail -l | cut -d’ ‘ -f2’ if [ $HISTORY -qt 1000 ]; then echo “some command will gone”else echo “OK”fi123文件判断练习：判断一个文件是否存在例/etc/inittab #!/bin/bash#FILE=/etc/inittab if [ -e $FILE ]; then echo “OK”else echo “No such file”fi123456练习：给定一个文件；如果是一个普通文件，就显示；如果是一个目录，也显示；否则，显示此为无法识别文件；定义状态码222； #!/bin/bash#FIEL=/etc/inittab if [ ! -e $FILE ]; then echo “No such file” exit 222fi if [ -f $FILE ]; then echo “Common file”elif [ -d $FIEL ]; then echo “Directory”else echo “Unknown”fi12345示例：(变量运用）脚本名称为filetest接受一个参数（文件路径）判定：此参数如果是存在文件，显示“OK”；否则显示“No such file” #!/bin/bash#if [ $# -lt 1 ]; then echo “Usage : ./filetest.sh ARG1 [ARG2 …]” exit 7fi if [ -e $1 ]; then echo “OK”else echo “No such file”fi123456执行：./filetest.sh /etc/inittab示例：（shift轮换用法）shift命令可以一次行轮换多条参数，默认为1脚本名称为：shift #!/bin/bash#echo $1shiftecho $1shiftecho $112345678执行：./shift.sh 1 2 3显示： 1 2 3多个轮换参数 #!/bin/bash#echo $1shift 2echo $1shift 2echo $112345678910执行：./shift.sh 1 2 3 4 5 显示： 1 3 5练习：给脚本传递两个参数（整数）；显示此两者之和，和乘积； #!/bin/bash#if [ $# -lt 2 ]; then echo “Usage:calc.sh ARG1 ARG2” exit 3fi echo “The sum is: $[$1+$2]”echo “The prod is：$[$1*$2]”```]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash变量]]></title>
    <url>%2F2017%2F04%2F22%2Fbash_%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[bash语言类型、变量分类 shell编程： 计算机：运行二进制指令编译器，解释器 编程语言：机器语言，汇编语言，高级语言 高级语言： 静态语言：编译型语言 强类型（变量在使用前，必须事先声明，甚至还需要初始化） 事先转换成可执行格式 C、c++、java、C# 动态语言：解释型语言 弱类型（解释器） 边解释边执行 PHP、SHELL、python、perl 程序：指令+数据 程序编程风格： 面向过程：以指令为中心，数据服务于指令，比较适合大型场景 shell、C 面向对象：以数据为中心，指令服务于数据，比较适合小环境 java、python、perl、C++ shell程序：提供了编程能力，解释执行 变量：内存空间，命名的内存空间 强类型变量： 显式转换： 变量不经过强制转换永远是这个数据 不允许隐式转换 一般定义变量是必须指定类型 参与运算必须复合类型 调用变量需要先声明变量并初始化 变量在没有初始化之前是一段随机数，强类型引用前多数需要进行初始化变量。 初始化（默认初始化）： 字符串使用前为空；null 数值使用前为零；0 弱类型变量： 隐式转换： 语言运行时会隐式转换数据类型 无需指定类型 默认为字符型 在内部进行转换后进行运算 变量用时声明，其实就是直接使用 显示已定义的所有变量：’set’删除变量：’unset name’​内存：编址的存储单元 进程：程序是指令、数据及其组织形式的描述，进程是程序的实体 变量类型：事先确定数据的存储格式和长度 字符 数值 整数型 浮点型 真、假 变量附值：VAR_NAME=VALUE 整形： 8bit保存256：0~255，后果溢出（溢出后只能保留其后8位数值），溢出会占用其他进程的数据 缓冲区攻击：通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出简单的防止方法，当用户需要填入变量的时候首先进行条件判断,变量是否能够存下，能存下保存不能存储直接拒绝。判断方式：根据变量类型和大小进行判断； 逻辑运算：与、或、非、异或 （0为假，其他为真）与（&amp;） ：乘积计算，只要有一个为假，结果一定为假；或（|） ：求和计算，只要有一个为真，结果一定为真；非（！）：求反计算 bash变量类型： 根据变量作用范围和变量表示类型划分； 环境变量： 生效范围为当前shell进程及其子进程生效； 本地变量： 生效范围为前shell进程 对当前shell之外的其他shell进程均无效（包括当前shell的子shell进程）； 局部变量 生效范围为当前shell进程中某代码片段（通常指函数）； 位置变量： $1,$2,…来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数； 特殊变量： $? $0 $* $@ $# $$ 本地变量： 变量附值：VAR_NAME=’value’ 可以使用引用value: 1.可以是直接字符串name=&apos;root&apos; 2.变量引用$name=&apos;$USER&apos; 3.命令引用name=&apos;command&apos; neme=$(command) 变量引用：${name};$name “”：弱引用，其中的变量引用会被替换为变量值； ‘’：强引用，七中的变量引用不会被替换为变量值，而是保持原字符串； {}：在容易引起变量混淆的情况下需要加{}，其他情况不需要加{}。 例如：ANIMAL=pig,${ANIMAL}s=pigs 环境变量： 变量声明，赋值export name = VALUE declare -x name = VALUE 显示所有环境变量：env printenv export declare -x 删除变量：unset name bash内建的环境变量：123456789101112-PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE 只读变量：只能声明，但不能修改和删除 声明只读变量： readonly name declare -r name 查看只读变量： readonly -P 位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1,$2,…：对应第一，第二等参数，shift[n]换位置$0 ：命令本身$# ：传递给脚本的参数的个数$ ：传递给脚本的所有参数，全部参数合为一个字符串$@ ：传递给脚本的所有参数，每个参数为独立字符串$,$@：只在被双引号好起来的时候再回有差异set -- ：清空所有位置变量 退出状态进程使用退出状态来报告成功或失败 0 ：代表成功 1~255：代表失败 1、2、127系统预留 $?：变量保存最近的命令退出状态例如： ping -c1 -w1 hostdown &amp;&gt; /dev/null; echo $? 退出状态码：bash自定义退出状态码： exit [n]：自定义退出状态码注意： 脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字； 如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码； 算数运算bash中的算数运算：help let +、-、、/、%取模（取余）、*乘方 实现算数运算：12345678let var = 算数表达式var = $[算数表达式]var = $((算数表达式))var = $(expr arg1 arg2 arg3 ...)declare -i var = 数值echo &apos;算术表达式&apos; | bc乘法符号有些场景中需要转义 例如：* bash有内建的随机数生成器： $RANDOM (0-32767) 例如：echo $[RANDOM %50] 0-49之间的随机数 赋值：增强型赋值： +=，-=，*=，/=，%=let var OPER value 例如：let count += 3 自身加3后自附值自增，自减： let var += 1 let var ++ let var -= 1 let var – 逻辑运算： true ：1 false ：0与（&amp;） ：乘积计算，乘积为1时为真，其余为假或（|） ：求和计算，求和为0时为假，其余为真非（！）：求反计算，!0=1，!1=0 短路运算 短路与当乘积为0时，结果为假当乘积为1时，需要继续执行计算 短路或当求和为非0时，结果为真当求和为0时，需要继续执行计算 异或：异或的两个值，相同为假，不同为真 条件测试判断其需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助来测试过程 评估布尔声明，以便用在条件性执行中 若真，则返回0 若假，则返回1 测试命令1234etxt EXPRESSION[ EXPRESSION ][[ EXPRESSION ]]注：EXPRESSION 表达式前后必须有空白字符 条件性的执行操作符根据退出状态而定，命令可以有条件的运行 &amp;&amp; 代表条件行的 AND THEN || 代表条件性的 OR ELSE hash的配置文件按生效范围划分，存在两类： 全局配置： /etc/profile /etc/profile.d/*.sh /etc/bashrc 个人配置： ~/.hash_profile ~/.bashrc shell登录的两种方式： 交互式登录： 直接通过终端输入帐号密码登录 使用 su -USERNAME 切换用户 执行顺序： /etc/profile /etc/profile.d/*.sh ~/.bash_profile ~/.bashrc /etc/bashrc 非交互式登录: su USERNAME 图形界面下打开的终端 执行脚本 任何其他的hash实例 执行顺序： ~/.bashrc /etc/bashrc /etc/profile.d/*.sh 按功能划分，存在两类： profile类和bashrc类profile类：为交互式登录的shell提供配置 全局： /etc/profile /etc/profile.d/*.sh 个人： ~/.bash_profile 功用： 用于定义环境变量 运行命令或脚本 bashrc类： 为非交互式和交互式登录的shell提供配置 全局： /etc/bashrc 个人： ~/.bashrc功用: 定义命令别名和函数 定义本地变量 编辑配置文件生效修改profile和bashrc文件后需生效两种方法： 重新启动shell进程 source或“.” 例如：.~/.bashrc bash退出任务保存在~/.bash_logout文件中（用户）在退出登录shell时运行用于 创建自动备份 清楚临时文件 $ -变量h：hashall，打开这个选项后，shell会讲明in个所在的路径hash下来，避免每次都要查询。 通过she -h将h选项关闭i：interactive-comments，包含这个选项说明当前的shell是一个交互式的shell。 所谓的交互式shell，在脚本中，i选项是关闭的m:monitor，打开监控模式就可以通过job control来控制进程和停止，继续，后台或者前台执行等B：braceexpand，大括号扩展H：history，H选项打开，可以展开历史列表中的命令，可以通过！感叹号来完成。 例如： !!：返回最近的一个历史命令 !n：返回第n个历史命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep使用方法]]></title>
    <url>%2F2017%2F04%2F21%2Fbash_grep%2F</url>
    <content type="text"><![CDATA[三剑客之grep grep 命令 grep、egrep、fgrep grep：根据模式搜索文本，并将符合模式的问恩行显示出来Pattern（模式）：文本字符和正则表达式的元字符组合而成匹配条件 grep [OPTIONS] PATTERN [FILE…]grep [OPTIONS] [-e PATTERN | -f FILE] [FILE…]12345例： grep root /etc/passwd grep &quot;$USER&quot; /etc/passwd grep &apos;$USER&apos; /etc/passwd grep `whoami` /etc/passwd grep 选项： 默认使用基本正则表达是定义的模式来过滤文本的命令； –color：高亮显示 -i：忽略大小写 -v：反向搜索，显示没有被模式匹配到的行 -o：只显示被模式匹配到的字符串 -q：静默模式，不输出任何信息 -n：显示匹配的行号 -c：统计匹配的行数 -A #：after，后#行 -B #：before，前#行 -C #：context，前后各#行 -e：实现多个选项间的逻辑or关系 例：grep –e ‘cat’ -e ‘dog’ file -w：匹配整个单词 -E：使用ERE，使用扩展正则表达式 -F：相当于fgrep，不支持正则表达式 扩展正则表达式：EREegrep = grep -E 语法：egrep [OPTIONS] PATTERN [FILE…] 快速模式搜索：fast grepfgrep：不支持正则表达式在fgrep搜索中所有正则表达式将被当成字符来进行搜索匹配]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>三剑客</tag>
        <tag>bash</tag>
        <tag>正则表达式</tag>
        <tag>文本工具</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式总结]]></title>
    <url>%2F2017%2F04%2F21%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式常用总结 正则表达式：Regular Expression，简写RE分两类： 基本正则表达式：BRE 扩展正则表达式：ERE 正则表达式是对字符串操作的一种逻辑公式 包括: 普通字符（例如，a 到 z 之间的字母） 特殊字符（称为“元字符”） 元字符分类： 字符匹配 匹配次数 位置锚定 分组 字符匹配： 元字符 表示含义 . 任意单个字符 [] 匹配指定范围内的任意单个字符 [^] 匹配指定范围外的任意字符 字符集合：元字符：表示含义[:alnum:]：字母和数字[:alpha:]：代表任何英文大小写字符，亦即 A-Z, a-z[:lower:]：小写字母[:upper:]：大写字母[:blank:]：空白字符（空格和制表符）[:space:]：水平和垂直的空白字符（比[:blank:] 包含的范围广）[:cntrl:]：不可打印的控制字符（退格、删除、警铃…）[:digit:]：十进制数字[:xdigit:]：十六进制数字[:graph:]：可打印的非空白字符[:print:]：可打印字符[:punct:]：标点符号 匹配次数： 用在要指定次数的字符后面，用于指定前面的字符要出现的次数 （默认贪婪模式）元字符：表示含义 *：匹配其前面的字符，任意次；.*：匹配其前面的字符，任意长度任意字符；\?：匹配其前面的字符，1或0次；\+：匹配其前面的字符，至少1次；\{n\}：匹配其前面的字符，n次；\{m,n\}：匹配其前面的字符，至少m次，至多n次；\{,n\}：匹配其前面的字符，至多n次；\{n,\}：匹配其前面的字符，至少n次； “\”：代表的转义符，也可以称作逃逸符。如果\{\}不添加转义符，会被bash认为是字符展开。 位置锚定：锚定出现的位置 元字符 表示含义 ^ 锚定行首，此字符后面的内容必须在行首； $ 锚定行尾，此字符前面的内容必须在行尾； ^PATTERN$ 用于模式匹配整行； ^$ 空行； ^[[:space:]]*$ 空白行； \&lt;或\b 词首锚定，用于单词模式的左侧； >或\b 词尾锚定，用于单词模式的右侧； \ 匹配整个单词； 分组：()：将一个或多个字符捆绑在一起，当作一个整体进行处理； 例如： (abc)* (root)+ (xyz)\?分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中。这些变量的命名方式为: \1, \2, \3, … \1 ：表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符； \2：表示从左侧起第二个左括号以及与之匹配右括号之间的模式所匹配到的字符； \3 ：据上依次类推；示例： (string1+(string2)*) \1 ：string1+(string2)* \2 ：string2 后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身 |：或者 示例：a|b ：a或b；C|cat ：C或cat；(C|c)at ：Cat或cat； 扩展正则表达式：ERE字符匹配：. 任意单个字符[] 指定范围的字符[^] 不在指定范围的字符 次数匹配：扩展正则中的“{}”不需要逃逸符“\” *：匹配前面字符任意次（“?+”与其意义相同）?：0或1次+：1次或多次（类似于标准正则中的“{1,}”）{m}：匹配m次{m,n}：至少m，至多n次 位置锚定：^ ：行首$ ：行尾\&lt;, \b ：语首\&gt;, \b : 语尾 分组：扩展正则中的“()”不需要逃逸符“\” ()后向引用：\1, \2, … 或者：a|b :a或bC|cat :C或cat(C|c)at :Cat或cat]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>正则表达式</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
</search>
