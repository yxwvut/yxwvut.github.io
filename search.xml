<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LINUX KERNEL启动参数]]></title>
    <url>%2F2017%2F08%2F19%2FLINUX%20KERNEL%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[kernel在grub中配置的启动参数 在Linux中，给kernel传递参数以控制其行为总共有三种方法： 1. build kernel之时的各个configuration选项。 2. 当kernel启动之时，可以参数在kernel被GRUB或LILO等启动程序调用之时传递给kernel。 3.在kernel运行时，修改/proc或/sys目录下的文件。 这里讲的就是第二种方式了，kernel在grub中配置的启动参数。 首先，kernel有哪些参数呢？ 在linux的源代码中，有这样的一个文档Documentation/kernel-parameters.txt ，它介绍了kernel的各个参数及其意义。 其次，kernel启动参数以空格分隔，而且是严格区分大小写的 例如：mem和MEM是不一样的 再次，对于module特有的kernel参数写法是这样的，[module name].[parameter=XX]， 例如，igb.max_vfs=7 这个kernel启动参数的效果就是相当于这样来动态加载module: modprobe igb max_vfs=7 另外，kernel是怎样处理这些启动参数的呢？ 启动参数通常是这样的形式： name[=value_1][,value_2]…[,value_10] “name”是关键字，内核用它来识别应该把”关键字”后面的值传递给谁，也就是如何处理这个值，是传递给处理进程还是作为环境变量或者抛给”init”。 值的个数限制为10，你可以通过再次使用该关键字使用超过10个的参数。 kernel检查关键字是不是 ‘root=’, ‘nfsroot=’, ‘nfsaddrs=’, ‘ro’, ‘rw’, ‘debug’ 或 ‘init’ 内核在bootsetups数组里搜索于该关键字相关联的已注册的处理函数，如果找到相关的已注册的处理函数，则调用这些函数并把关键字后面的值作为参数传递给这些函数。 比如，你在启动时设置参数 name＝a、b、c、d，内核搜索 bootsetups 数组，如果发现”name”已注册，则调用”name”的设置函数如 name_setup()，并把 a、b、c、d 传递给 name_setup() 执行。 所有型如”name＝value”参数，如果没有被上面所述的设置函数接收，将被解释为系统启动后的环境变量 比如”TERM=vt100”启动参数就会被作为一个启动后的环境变量。 所有没有被内核设置函数接收也没又被设置成环境变量的参数都将留给init进程处理 比如”single” 下面简单总结一些常用到的一些kernel启动参数。 根磁盘相关启动参数： root # 指出启动的根文件系统 如：root=/dev/sda1 ro # 指定根设备在启动过程中为read-only，默认情况下一般都是这样配的 rw # 和ro类似，它是规定为read-write，可写 rootfstype # 根文件系统类型，如：rootfstype=ext4 Console和kernel log相关启动参数： console # console的设备和选项，如：console=tty0 console=ttyS0 debug # enable kernel debugging 启动中的所有debug信息都会打印到console上 quiet # disable all log messages 将kernel log level设置为KERN_WARNING，在启动中只非常严重的信息 loglevel # 设置默认的console日志级别，如：loglevel=7 （0~7的数字分别为：KERN_EMERG,..,KERN_DEBUG） time # 设置在每条kernel log信息前加一个时间戳 内存相关的启动参数： mem # 指定kernel使用的内存量，mem=n[KMG] hugepages # 设置大页表页（4MB大小）的最多个数，hugepages=n CPU相关的启动参数： mce # Enable the machine check exception feature. nosmp # Run as a single-processor machine. 不使用SMP（多处理器） max_cpus # max_cpus=n, SMP系统最多能使用的CPU个数（即使系统中有大于n个的CPU） Ramdisk相关的启动参数： initrd # 指定初始化ramdisk的位置，initrd=filename noinitrd # 不使用initrd的配置，即使配置了initrd参数 初始化相关启动参数： init # 在启动时去执行的程序，init=filename，默认值为/sbin/init PCI相关的启动参数： pci # pci相关的选项，我常使用pci=assign_buses，也使用过pci=nomsi SELinux相关启动参数： enforcing # SELinux enforcing状态的开关，enforcing=0表示仅仅是记录危险而不是阻止访问，enforcing=1完全enable，默认值是0 selinux # 在启动时关闭或开启SELinux，selinux=0表示关闭，selinux=1表示开启selinux 另外，还是用max_loop来指定最多可使用的回路设备。 在Redhat的系统中，还有个经常看到的kernel启动参数——rhgb，rhgb表示redhat graphics boot，就是会看到图片来代替启动过程中显示的文本信息，这些信息在启动后用dmesg也可以看到rhgb = redhat graphical boot – This is a GUI mode booting screen with most of the information hidden while the user sees a rotating activity icon spining and brief information as to what the computer is doing. quiet = hides the majority of boot messages before rhgb starts. These are supposed to make the common user more comfortable. They get alarmed about seeing the kernel and initializing messages, so they hide them for their comfort. 参考资料:linux kernel documents 《Linux kernel in a nutshell》]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用RAID技术总结]]></title>
    <url>%2F2017%2F07%2F21%2FRAID(Redundant%20Array%20of%20Independent%20Disks)%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常用RAID(Redundant Array of Independent Disks)技术总结 RAID 0 : RAID 0 并不是真正的RAID结构，没有数据冗余，没有数据校验的磁盘陈列。 实现RAID 0至少需要两块以上的硬盘，它将两块以上的硬盘合并成一块，数据连续地分割在每块盘上。因为带宽加倍，所以读/写速度加倍， 但RAID 0在提高性能的同时，并没有提供数据保护功能，只要任何一块硬盘损坏就会丢失所有数据。因此RAID 0 不可应用于需要数据高可用性的关键领域。 RAID 1 : RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。 当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。RAID 1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。RAID 1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAID 0磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID 1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID 1磁盘阵列一般支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID 1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID 1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。 RAID 10 : RAID 1+0 也被称为RAID 10标准，实际是将RAID 0和RAID 1标准结合的产物，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘作磁盘镜像进行冗余。 它的优点是同时拥有RAID 0的超凡速度和RAID 1的数据高可靠性，但是CPU占用率同样也更高，而且磁盘的利用率比较低。由于利用了RAID 0极高的读写效率和RAID 1较高的数据保护、恢复能力，使RAID 10成为了一种性价比较高的等级，目前几乎所有的RAID控制卡都支持这一等级。但是，RAID 10对存储容量的利用率和RAID 1一样低，只有50%。因此，RAID10即高可靠性与高效磁盘结构它是一个带区结构加一个镜象结构，可以达到既高效又高速的目的，RAID 10能提供比RAID 5更好的性能。这种新结构的可扩充性不好，这种解决方案被广泛应用，使用此方案比较昂贵。 RAID 5 : RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。RAID 5可以为系统提供数据安全保障，但保障程度要比Mirror低而磁盘空间利用率要比Mirror高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前运用较多的一种解决方案。RAID5数据以块为单位分布到各个硬盘上。RAID 5不对数据进行备份，而是把数据和与其相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。 RAID 6 : RAID6技术是在RAID 5基础上，为了进一步加强数据保护而设计的一种RAID方式，实际上是一种扩展RAID 5等级。 与RAID 5的不同之处于除了每个硬盘上都有同级数据XOR校验区外，还有一个针对每个数据块的XOR校验区。当然，当前盘数据块的校验数据不可能存在当前盘而是交错存储的，这样一来，等于每个数据块有了两个校验保护屏障（一个分层校验，一个是总体校验），因此RAID 6的数据冗余性能相当好。但是，由于增加了一个校验，所以写入的效率较RAID 5还差，而且控制系统的设计也更为复杂，第二块的校验区也减少了有效存储空间。RAID-6和RAID-5一样对逻辑盘进行条带化然后存储数据和校验位，只是对每一位数据又增加了一位校验位。这样在使用RAID-6时会有两块硬盘用来存储校验位，增强了容错功能，同时必然会减少硬盘的实际使用容量。以前的raid级别一般只允许一块硬盘坏掉，而RAID-6可以允许坏掉两块硬盘，因此，RAID-6 要求至少4块硬盘。 常用RAID图示 常用RAID比较结论 RAID类型 访问速度 数据可靠性 磁盘利用率 RAID 0 很快 很低 100% RAID 1 很慢 很高 50% RAID 10 中等 很高 50% RAID 5 较快 较高 (n-1)/n RAID 6 较快 较(RAID5)高 (n-2)/n 更多信息请参照百度 参考资料百度百科 - RAID 0 : 百度百科 - RAID 0 百度百科 - RAID 1 : 百度百科 - RAID 1 百度百科 - RAID 10 : 百度百科 - RAID 10 百度百科 - RAID 5 : 百度百科 - RAID 5 百度百科 - RAID 6 : 百度百科 - RAID 6]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>理论</tag>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_RPM命令管理]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_RPM%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——RPM命令管理 RPM包命名原则 httpd-2.2.15-15.el6.centos.1.i686.rpm httpd软件包名 2.2.15软件版本 15软件发布的次数 el6.centos适合的linux平台,可能为rhel6代表Redhat6 i686适合的硬件平台，可能i386,x86_64,x64等 rpm rpm包扩展名 RPM包依赖 树形依赖：a-&gt;b-&gt;c 环形依赖：a-&gt;b-&gt;c-&gt;a 模块依赖：查询网站http://www.rpmfind.net/ 包全名和包名 包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径 包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm中的数据库 RPM安装123456[root@localhost ~]# rpm -ivh h&gt; 选项：&gt; -i(install) 安装&gt; -v(verbose) 显示详细信息&gt; -h(hash) 显示进度&gt; --nodeps 不检测依赖性 升级123[root@localhost ~]# rpm -Uvh 包全名&gt; 选项&gt; -U(upgrade) 升级 卸载1234[root@localhost ~]# rpm -e 包名&gt; 选项&gt; -e(erase) 卸载&gt; --nodeps不检查依赖性 RPM包查询1234567891011121314151617181920212223242526[root@localhost ~]# rpm -q 包名# 查询包是否安装&gt; -q 查询(query)[root@localhost ~]# rpm -qa# 查询所有已经安装的RPM包&gt; -a 所有(all)[root@localhost ~]# rpm -qi 包名# 查询软件包详细信息&gt; -i 查询软件信息(information)&gt; -p 查询未安装包信息(package)[root@localhost ~]# rpm -ql 包名# 查询包中文件安装位置&gt; -l 列表(list)&gt; -p 查询未安装包信息(package)[root@localhost ~]# rpm -qf 系统文件名# 查询系统文件属于哪个RPM包&gt; -f 查询系统文件属于哪个软件包(file)[root@localhost ~]# rpm -qR 包名# 查询软件包的依赖性&gt; -R 查询软件包的依赖性(requires)&gt; -p 查询未安装包信息(package) RPM包默认安装位置 路径 释义 /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 RPM包校验123456[root@localhost ~]# rpm -V 已安装的包名# RPM包校验&gt; 选项&gt; -V 校验指定RPM包中的文件(verify)S.5....T. c /etc/httpd/conf/httpd/conf 验证内容中的8个信息的具体内容如下： S 文件大小是否改变 M 文件的类型或文件的权限(rwx)是否被改变 5 文件MD5校验和是否改变(可以看成文件内容是否改变) D 设备的主从代码是否改变 L 文件路径是否改变 U 文件的属主(所有者)是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 验证的文件类型 c 配置文件(config file) d 普通文件(documentation) g 鬼文件(ghost file), 很少见，就是该文件不应该被这个RPM包包含 L 授权文件(license file) r 描述文件(read me) RPM包中文件提取123[root@localhost ~]# rpm2cpio 包全名 | cpio -idv .文件绝对路径&gt; -rpm2cpio 将rpm包转换为cpio格式的命令&gt; -cpio 是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 cpio 12345[root@localhost ~]# cpio 选项 &lt; [文件|设备]&gt; 选项&gt; -i:copy-in模式，还原&gt; -d:还原时自动新建目录&gt; -v:显示还原过程]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_源码包安装]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——源码包安装 源码包与RPM包区别RPM包安装指定安装位置rpm --help|grep prefix 虽然可以指定安装路径，但是不建议这么做 源码包安装位置安装在指定位置当中，一般是 /usr/local/软件名 区别安装之前的区别：概念上的区别安装之后的区别：安装位置不同源码包通常运行效率会更好 源码包安装过程安装前准备 安装C语言编译器 gcc 下载源码包 安装前注意事项 源代码保存位置：/usr/local/src/ 软件安装位置：/usr/local/ 如何确定安装过程报错 安装过程停止 并出现error，warning或no的提示 源码包安装过程 下载源码包 解压缩下载的源码包 进入解压缩目录 执行./configure软件配置与检查定义需要的功能选项检测系统环境是否符合安装要求把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑例子：./configure --prefix=/usr/local/apache2 make 编译make clean make install编译安装 安装须知查看INSTALL文件(大部分人会写在这)]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_软件包管理]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——软件包管理 源码包 优点: 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 卸载方便 缺点: 安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境)，容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错，新手很难解决 脚本安装包：就是把复杂的软件包安装过程写成了程序脚本，初学者可以执行程序脚本实现一键安装。但实际安装的还是源码包和二进制包 优点是安装简单快捷 缺点是完全丧失了自定义性 二进制包（RPM包，系统默认包） 优点: 包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载 安装速度比源码包安装快很多 缺点： 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux_YUM在线安装]]></title>
    <url>%2F2017%2F06%2F29%2Flinux_YUM%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Linux环境下的文件管理——YUM在线安装 文件目录/etc/yum.repos.d 默认文件 CentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo CentOS-Base.repo1234567[base]name=CentOS-$releaserver - Basemirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os#baseurl=http://mirror.centos.org/centos/$releasevver/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm=gpg/RPM-GPG-KEY=CentOS-6#上述中file后面`://`双斜杠代表的是协议的意思，即file协议 vi /etc/yum.repos.d/CentOS-Base.repo [base] 容器名称，一定要放在[]中 name 容器说明，可以自己随便写 mirrorlist 镜像站点，这个可以注释掉 baseurl 我们的YUM源服务器的地址，默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址 enabled 此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效 gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效 gpgkey 数字证书的公钥文件保存位置，不用修改 光盘搭建yum源挂载光盘1234#建立挂载点mkdir /mnt/cdrom#挂载光盘mount /dev/cdrom mnt/cdrom 使网络Yum源失效1234#进入yum源目录cd /etc/yum.repos.d/#修改yum源文件后缀名，使其失效mv CentOS-Base.repo CentOS-Base.repo.bak 使光盘Yum源生效vim CentOS-Media.repo 12345678[c6-media]name=CentOS-$releasever - Mediabasrurl=file://mnt/cdrom # 地址为你自己的光盘挂载地址# file:///media/cdrom# file:///media/cdrecorder # 注释这两个不存在的地址gpgcheck=1enabled=1 # 把enabled=0改为enabled=1，让这个yum源配置文件生效gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 Yum命令123456789101112131415161718192021222324252627282930313233343536373839# 查询所有软件包列表[root@localhost ~]# yum list# 搜索服务器上所有和关键字相关的包[root@localhost ~]# yum search 关键字# 安装命令[root@localhost ~]# yum -y install 包名 - 选项： &gt; install 安装 &gt; -y 自动回答yes[root@localhost ~]# yum -y install gcc # C语言编译器# 升级命令[root@localhost ~]# yum -y update 包名 - 选项： &gt; update 升级 &gt; -y 自动回答yes# 升级本服务器下所有的安装包，并且更新linux新内核，慎用，CentOS6.3及以前会有问题[root@localhost ~]# yum -y update# 卸载[root@localhost ~]# yum -y remove 包名 - 选项： - remove 卸载 - -y 自动回答yes# 服务器使用最小化安装，用什么软件安装什么，尽量不卸载# 列出所有可用的软件组列表[root@localhost ~]# yum grouplist# 安装指定软件组，组名可以由grouplist查询出来[root@localhost ~]# yum groupinstall 软件组名# 注意：软件组名必须是英文LANG=en_US # 修改语言，让显示的grouplist是英文列表# 卸载指定软件组[root@localhost ~]# yum groupremove 软件组名]]></content>
      <categories>
        <category>文件管理</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS根服务器模拟实验]]></title>
    <url>%2F2017%2F06%2F21%2FDNS-root_server-simulated%2F</url>
    <content type="text"><![CDATA[使用虚拟机模拟根服务器进行DNS解析 DNS访问的顺序 实现DNS转发模拟实验，需要6台虚拟机 VM IP 简称 C 172.18.51.12 12 S 172.18.51.13 13 根 172.18.51.14 14 com 172.18.51.15 15 主 172.18.51.16 16 从 172.18.51.17 17 配置思路顺序：主&gt;从&gt;com&gt;根&gt;S&gt;C 实验前请妥善备份好自己的配置文件，本实验需要配置变更目录为123456/etc/named.conf/var/named/named.ca/etc/named.rfc1912.zones/var/named/root.zone /com.zone /nigaha.com.zone 实验过程中可能需要的12345检查named.conf文件语法：named-checkconf [filename]检查区域配置文件语法：named-checkzone zone [filename]dig “域名” @IP 配置前为了放置中间出现意外首先确定关闭selinux，清空iptables，安装bind 一、在14中配置12345vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 让域内所有服务器知道自己是根服务器123456789vim /var/named/named.ca修改 ;; QUESTION SECTION: ;. IN NS ;; ANSWER SECTION: . 518400 IN NS a.root-servers.net. a.root-servers.net. 3600000 IN A 172.18.51.14下面多余部分删掉就可以不放心可以注释掉 分发/var/named/named.ca给所有主机13、15、16、171234scp /var/named/named.ca 172.18.51.17:/var/namedAre you sure you want to continue connecting (yes/no)? yesroot@172.18.51.17&apos;s password:named.ca 100% 478 0.5KB/s 00:00 在/etc/named.rfc1912.zones中配置根123456vim /etc/named.rfc1912.zones#添加zone &quot;.&quot; IN &#123; type master; file &quot;root.zone&quot;;&#125;; 在/etc/named.conf文件中有个根的指向需要删除123456vim /etc/named.conf#删除或注释掉下面内容# zone &quot;.&quot; IN &#123;# type hint;# file &quot;named.ca&quot;;# &#125;; 然后对com进行委派1234567891011121314vim /var/named/root.zone$TTL 86400 ; 1 day@ IN SOA dns1 admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1 #dns1是本机com NS dns2 #com指向dns2dns1 A 172.18.51.14 #本机地址dns2 A 172.18.51.15 #dns2指向com的ip 重启服务，7版本和6版本不一样 15中配置先修改配置,先建立com123456vim /etc/named.rfc1912.zones#添加zone &quot;com&quot; &#123; type master; file &quot;com.zone&quot;;&#125;; 创建com的域123456789101112131415161718vim /var/named/com.zone$TTL 86400 ; 1 day@ IN SOA dns1.nigaha.com. admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1nigaha NS dns2nigaha NS dns3dns1 A 172.18.51.15dns2 A 172.18.51.16dns3 A 172.18.51.16websrv A 172.18.51.111www CNAME websrv 如果com拥有从服务器的话dns1中ip必须为本机ip，不然不影响实验效果（另外需要再加条NS记录指向从服务器也就是dns3，如果不加不影响效果，但是你要的从服务器就没卵用了）注意！！！重启服务 套路有点不对，现在配主从服务器 二、在16中配置在“options”的段里1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 配置域1234567#添加vim /etc/named.rfc1912.zoneszone &quot;nigaha.com&quot; &#123; type master; file &quot;nigaha.com.zone&quot;;// allow-transfer &#123; any;&#125;; #这个可以忽略&#125;; 创建区域数据文件1234567891011121314151617vim /var/named/nigaha.com.zone$TTL 86400 ; 1 day@ IN SOA dns1.nigaha.com. admin.nigaha.com. ( 1002 ; serial 86400 ; refresh (1 day) 3600 ; retry (1 hour) 604800 ; expire (1 week) 10800 ; minimum (3 hours) ) NS dns1.nigaha.com. NS dns2.nigaha.com.dns1 A 172.18.51.14dns2 A 172.18.51.17websrv A 172.18.51.14www CNAME websrv 三、在17中配置在“options”的段里1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 配置域123456#添加zone &quot;nigaha.com&quot; &#123; type slave; masters &#123;172.18.51.16; &#125;; file &quot;slaves/nigaha.com.slaves.zone&quot;;&#125;; 看看有木有域数据文件呀12cd /var/named/slaves;lsnigaha.com.slaves.zone 四、在13中配置先确定下根在不在12345678vim /var/named/named.ca;; QUESTION SECTION:;. IN NS;; ANSWER SECTION:. 518400 IN NS a.root-servers.net.a.root-servers.net. 3600000 IN A 172.18.51.14 #对的就是他！ 查看配置文件/ect/named.conf1234vim /etc/named.conf注释掉 # listen-on port 53 &#123; 127.0.0.1; &#125;; # allow-query &#123; localhost; &#125;; 重启服务！重启服务！重启服务！ 五、在12号验证123456789101112131415161718192021222324252627dig www.nigaha.com @172.18.51.13; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.62.rc1.el6 &lt;&lt;&gt;&gt; www.nigaha.com @172.18.51.13;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59258;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 2;; QUESTION SECTION:;www.nigaha.com. IN A;; ANSWER SECTION:www.nigaha.com. 86400 IN CNAME websrv.nigaha.com.websrv.nigaha.com. 86400 IN A 172.18.51.14;; AUTHORITY SECTION:nigaha.com. 86400 IN NS dns1.nigaha.com.nigaha.com. 86400 IN NS dns2.nigaha.com.;; ADDITIONAL SECTION:dns2.nigaha.com. 86400 IN A 172.18.51.17dns1.nigaha.com. 86400 IN A 172.18.51.14;; Query time: 11 msec;; SERVER: 172.18.51.13#53(172.18.51.13);; WHEN: Mon Sep 25 10:52:43 2017;; MSG SIZE rcvd: 139 成功！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DNS</tag>
        <tag>服务servers</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建静态博客]]></title>
    <url>%2F2017%2F05%2F21%2Fgithub%2Bhexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo从开始到搭建成功 本篇所包含的内容如下： 安装Git Bash 安装NodeJs 安装hexo 生成SSH并添加到github 部署项目 上传到github 绑定个人域名 修改及配置主题 添加RSS 添加评论 写文章部分 1. 安装Git Bash首先准备好Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。 下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用。 下载地址(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量） 查看版本： 命令：node -v 3. 安装hexogitbash中用npm工具安装。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo 安装完成后，查看版本： 命令：hexo -v 初始化命令：hexo init 在你的目录会出现(master) 解释一下目录中文件作用： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 主要在_config.yml目录中进行配置，其他的目录不需要做太大改动。 4. 搭桥到github​ github网址 没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称。 回到gitbash中，配置github账户信息 创建SSH密钥在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。找到id_rsa.pub文件的内容。（记住密码，生成的密钥一般都在本地C盘user目录中） 将上面获取的ssh放到github中：添加一个 New SSH key ，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com（可以不做） 5. 配置主目录 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令： 123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装： 1npm i hexo-server 打开浏览器输入：http://localhost:4000 6. 上传到github 先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)： 123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： ​提示： INFO Deploy done: git信息部署完成 在浏览器中输入http://yourgithubname.github.io 如果再次推送的话hexo s本地测试无误后，使用hexo deploy就可以 7. 绑定个人域名可选 第一步购买域名：阿里云、腾讯云。DNS顺便弄了 第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是nigaha.com。 到DNS中添加记录：其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)： 8. 修改及配置主题 hexo初始化之后默认的主题是landscape , 想更换其他主题请点击更多hexo主题地址。在Search中搜索你要的主题名称。 跟该主题相关的配置在themes/hueman/_config.yml 在导航栏添加点东西 例如添加了一个更新日志的模块。 在主题的配置文件中，menu添加一栏：Board: /board。 然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。 在主题的hueman/langulages/zh-CN.yml中的index适当的位置加：board: &#39;更新日志&#39;，位置和名字是你自己设定。 重新部署，然后就OK了 在侧边栏添加点东西 回到你的主题的配置文件中，找到widgets一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫communiation且放在了第二行。 在上面所提到的zh-CN.yml文件中找到sidebar一栏，添加communiation: &#39;你要设的名称&#39;。 在hueman/layout/widget中添加一个communiation.ejs,填入模板 12345678&lt;% if (site.posts.length) &#123; %&gt;&lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;sidebar.communiation&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!--这里添加你要写的内容--&gt; &lt;/div&gt;&lt;/div&gt;&lt;% &#125; %&gt; 9. 添加RSS 先安装rss相关插件：npm i hexo-generator-feed 在你的项目的_config.yml配置文件下找到Extensions添加如下内容： 1234567891011# Extensions #插件和主题## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。 重新部署再打开就能看到效果啦~ 10. 添加评论20170812更新：云更贴已在2017年8月1日停止服务，具体评论系统文章统计站长统计及百度SEO谷歌SEO什么的可参考Hexo博客添加SEO-评论系统-阅读统计-站长统计-—-此段已失效。 先选一个你要使用的第三方评论系统。 在主题的配置文件下找到comment，添加一行，例如我添加的是yungentie: 此处自由发挥 注册完评论系统后获取相应的代码，然后在主题的layout下找到comment新建一个ejs模板文件，名称自定义。 找到你的article.ejs模板文件，加上&lt;%- partial(&#39;comment/你刚刚取得名字&#39;) %&gt;保存。 重新部署，OK啦 11. 文章部分 新建文章：hexo new &#39;文章名&#39;，然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。 关于具体的文章编辑你可以看下官网的介绍 markdown很容易上手]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
